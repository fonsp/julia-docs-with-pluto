### A Pluto.jl notebook ###
# v0.14.1

using Markdown
using InteractiveUtils

# ╔═╡ 2e539f5c-3b36-4ef2-93a7-f0c81badf70a
md"""
# Embedding Julia
"""

# ╔═╡ cd1fe3ec-1911-4dc2-81c0-00afe277bde5
md"""
As we have seen in [Calling C and Fortran Code](@ref), Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).
"""

# ╔═╡ 48d2cb81-acc7-4c01-bf5d-b1454e85a972
md"""
## High-Level Embedding
"""

# ╔═╡ b73a3f8a-9eb5-4e79-af1b-f6242253d175
md"""
**Note**: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.
"""

# ╔═╡ 53d2fc2e-aca3-48a0-b0f1-145a7dd6a487
md"""
We start with a simple C program that initializes Julia and calls some Julia code:
"""

# ╔═╡ ab0d872c-a3de-41ff-95c5-f14e81380d24
md"""
```c
#include <julia.h>
JULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(\"print(sqrt(2.0))\");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
```
"""

# ╔═╡ 6ae0e8af-5cf5-4ba6-84cc-af83933e4875
md"""
In order to build this program you have to put the path to the Julia header into the include path and link against `libjulia`. For instance, when Julia is installed to `$JULIA_DIR`, one can compile the above test program `test.c` with `gcc` using:
"""

# ╔═╡ cdb488be-2c16-4e30-9ca7-c5f0035f72f4
md"""
```
gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia
```
"""

# ╔═╡ f92daa58-3f98-4b33-94b0-2ad6940e4997
md"""
Alternatively, look at the `embedding.c` program in the Julia source tree in the `test/embedding/` folder. The file `cli/loader_exe.c` program is another simple example of how to set `jl_options` options while linking against `libjulia`.
"""

# ╔═╡ 96b2a72a-28ea-4c61-8454-e9cc96b07954
md"""
The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling `jl_init`, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use `jl_init_with_image` instead.
"""

# ╔═╡ 30a30a99-d6cd-4666-985e-3fadd7154c5a
md"""
The second statement in the test program evaluates a Julia statement using a call to `jl_eval_string`.
"""

# ╔═╡ 2b75a9ec-9e94-4957-9069-2b308e9fe308
md"""
Before the program terminates, it is strongly recommended to call `jl_atexit_hook`.  The above example program calls this before returning from `main`.
"""

# ╔═╡ 90b5d1ae-2c4e-4026-aa6e-fb20582036df
md"""
!!! note
    Currently, dynamically linking with the `libjulia` shared library requires passing the `RTLD_GLOBAL` option. In Python, this looks like:

    ```
    >>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
    >>> julia.jl_init.argtypes = []
    >>> julia.jl_init()
    250593296
    ```
"""

# ╔═╡ 4a89f5a9-56b4-45af-9623-16593dadc20c
md"""
!!! note
    If the julia program needs to access symbols from the main executable, it may be necessary to add `-Wl,--export-dynamic` linker flag at compile time on Linux in addition to the ones generated by `julia-config.jl` described below. This is not necessary when compiling a shared library.
"""

# ╔═╡ 10cc288d-0fbd-4b5d-9023-ac64946e02a1
md"""
### Using julia-config to automatically determine build parameters
"""

# ╔═╡ e5623d30-1a09-4798-a2f7-6adf7e4cdb39
md"""
The script `julia-config.jl` was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.
"""

# ╔═╡ c68e70d7-d20d-4fa2-8f8a-65ee7027f47b
md"""
#### Example
"""

# ╔═╡ 63f3f2a8-dda2-4a47-adfe-662900b2a291
md"""
```c
#include <julia.h>

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string(\"println(sqrt(2.0))\");
    jl_atexit_hook(0);
    return 0;
}
```
"""

# ╔═╡ 31a63eb7-4aac-4246-b243-e9b089252c79
md"""
#### On the command line
"""

# ╔═╡ 7cf64afa-5c18-4844-8de1-6d9c08df32ce
md"""
A simple use of this script is from the command line.  Assuming that `julia-config.jl` is located in `/usr/local/julia/share/julia`, it can be invoked on the command line directly and takes any combination of 3 flags:
"""

# ╔═╡ b56a4364-57bf-41e5-90bb-2ae93905ac3c
md"""
```
/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]
```
"""

# ╔═╡ 45073c38-fd9d-4d3e-bae9-f45de9a18fe7
md"""
If the above example source is saved in the file `embed_example.c`, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute `clang` for `gcc`.:
"""

# ╔═╡ 2147676b-0721-4881-90e6-cae828017764
md"""
```
/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c
```
"""

# ╔═╡ 183c5ba9-e349-44b7-bb7c-76137aa2718b
md"""
#### Use in Makefiles
"""

# ╔═╡ b7f9e82d-2acf-4ae5-8d2a-d964b6b615f9
md"""
But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the **shell** macro expansions.  Additionally, though many times `julia-config.jl` may be found in the directory `/usr/local`, this is not necessarily the case, but Julia can be used to locate `julia-config.jl` too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:
"""

# ╔═╡ 29c7a707-d177-457b-9876-7fc3b7ea99ef
md"""
```
JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\"))')
CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example
```
"""

# ╔═╡ 087ed0c5-6911-4029-8250-7ff3116fd123
md"""
Now the build command is simply `make`.
"""

# ╔═╡ 0bd5b05f-a4cd-46ce-8cf1-0109219edb1d
md"""
## High-Level Embedding on Windows with Visual Studio
"""

# ╔═╡ 0a50d2f8-1515-4a07-b72e-6469d5df6045
md"""
If the `JULIA_DIR` environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The `bin` folder under JULIA_DIR should be on the system PATH.
"""

# ╔═╡ 85824639-7399-40f3-a172-de92ab0043fd
md"""
We start by opening Visual Studio and creating a new Console Application project. To the 'stdafx.h' header file, add the following lines at the end:
"""

# ╔═╡ 2965e339-34b9-4054-980f-2ba91f84a986
md"""
```c
#include <julia.h>
```
"""

# ╔═╡ cf90f9de-e479-4d62-b149-1b2fc1dfc531
md"""
Then, replace the main() function in the project with this code:
"""

# ╔═╡ 7e287c1c-035f-49a4-b490-818e655422c7
md"""
```c
int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(\"print(sqrt(2.0))\");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
```
"""

# ╔═╡ fc3429b3-8770-4fee-8a14-684ec25ad390
md"""
The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.
"""

# ╔═╡ 052b38da-91ba-4e9e-870a-8a28038d2e7a
md"""
Using the project Properties dialog, go to `C/C++` | `General` and add `$(JULIA_DIR)\include\julia\` to the Additional Include Directories property. Then, go to the `Linker` | `General` section and add `$(JULIA_DIR)\lib` to the Additional Library Directories property. Finally, under `Linker` | `Input`, add `libjulia.dll.a;libopenlibm.dll.a;` to the list of libraries.
"""

# ╔═╡ ec28bce0-4d3b-4402-aa6a-bf20205d3ea0
md"""
At this point, the project should build and run.
"""

# ╔═╡ 6b66ab27-78e5-4fb9-8770-a1be7136cba9
md"""
## Converting Types
"""

# ╔═╡ 065eb446-d121-41f7-a571-52bb90ad139e
md"""
Real applications will not just need to execute expressions, but also return their values to the host program. `jl_eval_string` returns a `jl_value_t*`, which is a pointer to a heap-allocated Julia object. Storing simple data types like [`Float64`](@ref) in this way is called `boxing`, and extracting the stored primitive data is called `unboxing`. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:
"""

# ╔═╡ e9d6a537-b53a-46f3-9288-e17388c98410
md"""
```c
jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf(\"sqrt(2.0) in C: %e \n\", ret_unboxed);
}
else {
    printf(\"ERROR: unexpected return type from sqrt(::Float64)\n\");
}
```
"""

# ╔═╡ 9f47ffe9-a682-4aa6-bb1c-9e3e57cd8b5d
md"""
In order to check whether `ret` is of a specific Julia type, we can use the `jl_isa`, `jl_typeis`, or `jl_is_...` functions. By typing `typeof(sqrt(2.0))` into the Julia shell we can see that the return type is [`Float64`](@ref) (`double` in C). To convert the boxed Julia value into a C double the `jl_unbox_float64` function is used in the above code snippet.
"""

# ╔═╡ 3b83ab8f-0649-49a4-8bf3-055e8c4f5d99
md"""
Corresponding `jl_box_...` functions are used to convert the other way:
"""

# ╔═╡ 3ec3ab5e-3af2-4c1d-972c-07b9c7da3997
md"""
```c
jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);
```
"""

# ╔═╡ 4278f788-43c5-418a-a945-9a640e50f146
md"""
As we will see next, boxing is required to call Julia functions with specific arguments.
"""

# ╔═╡ eddab0ea-2c24-470c-8583-cd0c1f5c3dd8
md"""
## Calling Julia Functions
"""

# ╔═╡ 5e691d06-2906-403f-9a3b-d6312b26af45
md"""
While `jl_eval_string` allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using `jl_call`:
"""

# ╔═╡ 7eb40aaf-d8c1-42dc-8c15-d54325609684
md"""
```c
jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);
```
"""

# ╔═╡ d4588b3f-9c67-40b7-960a-ae1652396a02
md"""
In the first step, a handle to the Julia function `sqrt` is retrieved by calling `jl_get_function`. The first argument passed to `jl_get_function` is a pointer to the `Base` module in which `sqrt` is defined. Then, the double value is boxed using `jl_box_float64`. Finally, in the last step, the function is called using `jl_call1`. `jl_call0`, `jl_call2`, and `jl_call3` functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use `jl_call`:
"""

# ╔═╡ ad690967-4afb-4fef-b62a-2a57ec7c6c9c
md"""
```
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)
```
"""

# ╔═╡ 01ae8ea1-0d4d-4716-842b-928fb9ad8e8a
md"""
Its second argument `args` is an array of `jl_value_t*` arguments and `nargs` is the number of arguments.
"""

# ╔═╡ 08d99080-7a46-4a5a-9df2-877f12767bd6
md"""
## Memory Management
"""

# ╔═╡ b4a7ce77-5e90-4f56-8ffa-caac583eef7b
md"""
As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.
"""

# ╔═╡ 7974f36f-1435-4723-9a92-1ffac8d3bdf6
md"""
Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.
"""

# ╔═╡ 6804e206-efc3-4d8a-a695-312e57795d6c
md"""
The GC can only run when Julia objects are allocated. Calls like `jl_box_float64` perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between `jl_...` calls. But in order to make sure that values can survive `jl_...` calls, we have to tell Julia that we still hold a reference to Julia [root](https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf) values, a process called \"GC rooting\". Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the `JL_GC_PUSH` macros:
"""

# ╔═╡ bd41708b-f818-481f-9363-aaa1b6bb9cd1
md"""
```c
jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");
JL_GC_PUSH1(&ret);
// Do something with ret
JL_GC_POP();
```
"""

# ╔═╡ d422b618-10c0-4ce8-86bd-fe0734db8b98
md"""
The `JL_GC_POP` call releases the references established by the previous `JL_GC_PUSH`. Note that `JL_GC_PUSH` stores references on the C stack, so it must be exactly paired with a `JL_GC_POP` before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the `JL_GC_PUSH` was invoked.
"""

# ╔═╡ 8eef20b4-a574-45eb-9d0d-799f2685d42b
md"""
Several Julia values can be pushed at once using the `JL_GC_PUSH2` , `JL_GC_PUSH3` , `JL_GC_PUSH4` , `JL_GC_PUSH5` , and `JL_GC_PUSH6` macros. To push an array of Julia values one can use the `JL_GC_PUSHARGS` macro, which can be used as follows:
"""

# ╔═╡ 4b7f0402-7fa2-4753-8e5b-be15ed399668
md"""
```c
jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();
```
"""

# ╔═╡ 0ed17c6a-f8e5-4c74-b47e-68168ee77fc3
md"""
Each scope must have only one call to `JL_GC_PUSH*`. Hence, if all variables cannot be pushed once by a single call to `JL_GC_PUSH*`, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:
"""

# ╔═╡ 7c9c606a-b018-4700-bf80-d1e70da4f0f8
md"""
```c
jl_value_t *ret1 = jl_eval_string(\"sqrt(2.0)\");
JL_GC_PUSH1(&ret1);
jl_value_t *ret2 = 0;
{
    jl_function_t *func = jl_get_function(jl_base_module, \"exp\");
    ret2 = jl_call1(func, ret1);
    JL_GC_PUSH1(&ret2);
    // Do something with ret2.
    JL_GC_POP();    // This pops ret2.
}
JL_GC_POP();    // This pops ret1.
```
"""

# ╔═╡ 18e0f8cb-9a93-4630-b822-36abec311c2e
md"""
If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use `JL_GC_PUSH*`. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global `IdDict` that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.
"""

# ╔═╡ 6a4ddc9c-02c0-4722-83f4-0b66ca3e9952
md"""
```c
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string(\"refs = IdDict()\");
jl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.
var = jl_eval_string(\"[sqrt(2.0); sqrt(4.0); sqrt(6.0)]\");

// To protect `var`, add its reference to `refs`.
jl_call3(setindex, refs, var, var);
```
"""

# ╔═╡ c8e95606-2e83-4e74-b5ed-28fe51427e0d
md"""
If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a `RefValue{Any}` before it is pushed to `IdDict`. In this approach, the container has to be created or filled in via C code using, for example, the function `jl_new_struct`. If the container is created by `jl_call*`, then you will need to reload the pointer to be used in C code.
"""

# ╔═╡ 23a43a8e-02cc-49b2-96ef-5be79b1a1439
md"""
```c
// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string(\"refs = IdDict()\");
jl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(\"Base.RefValue{Any}\");

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.
var = jl_eval_string(\"sqrt(2.0)\");

// Protect `var` until we add its reference to `refs`.
JL_GC_PUSH1(&var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.
jl_value_t* rvar = jl_new_struct(reft, var);
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);
```
"""

# ╔═╡ 3564d6b4-0ea6-45ea-9dfe-7006c2cb7f07
md"""
The GC can be allowed to deallocate a variable by removing the reference to it from `refs` using the function `delete!`, provided that no other reference to the variable is kept anywhere:
"""

# ╔═╡ 43631c73-91f6-41bb-84ca-425c75423a7d
md"""
```c
jl_function_t* delete = jl_get_function(jl_base_module, \"delete!\");
jl_call2(delete, refs, rvar);
```
"""

# ╔═╡ a2989783-15df-470e-8093-9652bcb4f046
md"""
As an alternative for very simple cases, it is possible to just create a global container of type `Vector{Any}` and fetch the elements from that when necessary, or even to create one global variable per pointer using
"""

# ╔═╡ 30542234-91ed-4e54-8181-1c40a21b157e
md"""
```c
jl_set_global(jl_main_module, jl_symbol(\"var\"), var);
```
"""

# ╔═╡ 0076eb8e-6fca-454a-82ce-7a6ed3ba907b
md"""
### Updating fields of GC-managed objects
"""

# ╔═╡ 6650b69f-ee23-431a-8608-432850dc8328
md"""
The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the `jl_gc_wb` (write barrier) function like so:
"""

# ╔═╡ 8abcdb9c-6323-4b2c-b2ec-6db35f6e9aa0
md"""
```c
jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)->field = child;
jl_gc_wb(parent, child);
```
"""

# ╔═╡ 48ebc0e7-2f69-4b77-9515-57888c2c653a
md"""
It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the `parent` object was just allocated and garbage collection was not run since then. Remember that most `jl_...` functions can sometimes invoke garbage collection.
"""

# ╔═╡ b28147af-c6b8-4782-8700-ef61d4eb08ad
md"""
The write barrier is also necessary for arrays of pointers when updating their data directly. For example:
"""

# ╔═╡ 7d462765-f84e-4fd9-85b0-1fe308f6d85f
md"""
```c
jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);
```
"""

# ╔═╡ e81a625d-31b3-4ed1-9b8e-3594661413af
md"""
### Manipulating the Garbage Collector
"""

# ╔═╡ ac5c13b6-e1c8-4f7d-8531-30711702a61b
md"""
There are some functions to control the GC. In normal use cases, these should not be necessary.
"""

# ╔═╡ 6e046e3a-cf68-415f-9c6b-baf45b4d3050
md"""
| Function             | Description                                  |
|:-------------------- |:-------------------------------------------- |
| `jl_gc_collect()`    | Force a GC run                               |
| `jl_gc_enable(0)`    | Disable the GC, return previous state as int |
| `jl_gc_enable(1)`    | Enable the GC,  return previous state as int |
| `jl_gc_is_enabled()` | Return current state as int                  |
"""

# ╔═╡ 5a4683bb-ba41-41b3-82a3-31b1d118ee52
md"""
## Working with Arrays
"""

# ╔═╡ 1ce3b57c-e2f5-4b68-b91d-073a9991b662
md"""
Julia and C can share array data without copying. The next example will show how this works.
"""

# ╔═╡ bd84db51-1ddf-4863-8a58-9cf5dabbeb4f
md"""
Julia arrays are represented in C by the datatype `jl_array_t*`. Basically, `jl_array_t` is a struct that contains:
"""

# ╔═╡ 032ba679-8eb5-4341-b00e-2ee46c3b38ed
md"""
  * Information about the datatype
  * A pointer to the data block
  * Information about the sizes of the array
"""

# ╔═╡ cfa148a3-925c-4b5f-9343-c6760dd0ed0a
md"""
To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:
"""

# ╔═╡ 08e6053f-8055-49c6-8636-50598ad0f652
md"""
```c
jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);
```
"""

# ╔═╡ d0ff029c-e6c5-4d63-a219-48f1d0a02e36
md"""
Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:
"""

# ╔═╡ f12813ed-0579-47e4-a435-a93474391960
md"""
```c
double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);
```
"""

# ╔═╡ 917a9486-1638-4a78-bcc2-3f634838c3c9
md"""
The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call `free` on the data pointer when the array is no longer referenced.
"""

# ╔═╡ f4517aab-b46d-498e-88bb-f0663de68728
md"""
In order to access the data of x, we can use `jl_array_data`:
"""

# ╔═╡ 8c0b1899-c332-4444-b7fe-a822ab7fb34b
md"""
```c
double *xData = (double*)jl_array_data(x);
```
"""

# ╔═╡ d518179e-8d39-48a8-86fe-20a58fed5e94
md"""
Now we can fill the array:
"""

# ╔═╡ b44252dc-6ddc-4869-8454-58bdb6d4b72d
md"""
```c
for(size_t i=0; i<jl_array_len(x); i++)
    xData[i] = i;
```
"""

# ╔═╡ d5fc25c1-c91f-4993-aa72-34424f550832
md"""
Now let us call a Julia function that performs an in-place operation on `x`:
"""

# ╔═╡ e9017c01-f36b-499b-9306-8deab70e7177
md"""
```c
jl_function_t *func = jl_get_function(jl_base_module, \"reverse!\");
jl_call1(func, (jl_value_t*)x);
```
"""

# ╔═╡ c76e2821-0229-44b0-9008-e3bcd121e234
md"""
By printing the array, one can verify that the elements of `x` are now reversed.
"""

# ╔═╡ 8803945d-b527-4005-97a1-965885a4036e
md"""
### Accessing Returned Arrays
"""

# ╔═╡ c2614eba-fafb-44f8-a3d3-3ff38fe60920
md"""
If a Julia function returns an array, the return value of `jl_eval_string` and `jl_call` can be cast to a `jl_array_t*`:
"""

# ╔═╡ b13284f8-a5c0-4908-9cae-3ea8dc1f0ba1
md"""
```c
jl_function_t *func  = jl_get_function(jl_base_module, \"reverse\");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);
```
"""

# ╔═╡ 46244054-fa95-4f93-a30d-77c0821c6958
md"""
Now the content of `y` can be accessed as before using `jl_array_data`. As always, be sure to keep a reference to the array while it is in use.
"""

# ╔═╡ 0baa4787-144f-41ef-b5ab-b5c698bf0b87
md"""
### Multidimensional Arrays
"""

# ╔═╡ 3ffe513b-4480-4d61-9155-b7f2e46174c6
md"""
Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:
"""

# ╔═╡ cd7c4737-e148-442d-bad5-bbcd214ac317
md"""
```c
// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i<size1; i++)
    for(size_t j=0; j<size0; j++)
        p[j + size0*i] = i + j;
```
"""

# ╔═╡ c471b542-e038-48eb-9250-523db7075e87
md"""
Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling `jl_array_dim`) in order to read as idiomatic C code.
"""

# ╔═╡ bf153670-1920-4432-a0e2-16fdbaeb0a14
md"""
## Exceptions
"""

# ╔═╡ c6c887d2-00f8-49ee-b295-1a5783d81642
md"""
Julia code can throw exceptions. For example, consider:
"""

# ╔═╡ 40513dae-61ba-4499-a0eb-f65bf4b33856
md"""
```c
jl_eval_string(\"this_function_does_not_exist()\");
```
"""

# ╔═╡ bde373bb-c241-4d1f-b465-aa1eb1d2dc57
md"""
This call will appear to do nothing. However, it is possible to check whether an exception was thrown:
"""

# ╔═╡ dfd03d70-edeb-4652-a120-b801d52ac468
md"""
```c
if (jl_exception_occurred())
    printf(\"%s \n\", jl_typeof_str(jl_exception_occurred()));
```
"""

# ╔═╡ 072bc880-467f-4203-be68-78866a723aa5
md"""
If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into `libjulia` with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.
"""

# ╔═╡ 387e73ee-74a7-40d0-aceb-0e6f1d1e1e8e
md"""
### Throwing Julia Exceptions
"""

# ╔═╡ 4586d453-7a4f-4727-80ea-f867f0c3a227
md"""
When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:
"""

# ╔═╡ f1e786e7-c9c7-4976-9c02-f171bf09002a
md"""
```c
if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}
```
"""

# ╔═╡ 3c61fb70-169d-499e-864c-56de5f0a7364
md"""
General exceptions can be raised using the functions:
"""

# ╔═╡ 6d95c632-422c-4bf8-9f68-6cc94329827f
md"""
```c
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
```
"""

# ╔═╡ 755d72e0-a5be-4f3e-a224-8fcfe2248116
md"""
`jl_error` takes a C string, and `jl_errorf` is called like `printf`:
"""

# ╔═╡ c4019743-454c-485e-9c84-8c794f1dad87
md"""
```c
jl_errorf(\"argument x = %d is too large\", x);
```
"""

# ╔═╡ 3a96f527-3e27-49b7-a6c3-c25b71a1538f
md"""
where in this example `x` is assumed to be an integer.
"""

# ╔═╡ Cell order:
# ╟─2e539f5c-3b36-4ef2-93a7-f0c81badf70a
# ╟─cd1fe3ec-1911-4dc2-81c0-00afe277bde5
# ╟─48d2cb81-acc7-4c01-bf5d-b1454e85a972
# ╟─b73a3f8a-9eb5-4e79-af1b-f6242253d175
# ╟─53d2fc2e-aca3-48a0-b0f1-145a7dd6a487
# ╟─ab0d872c-a3de-41ff-95c5-f14e81380d24
# ╟─6ae0e8af-5cf5-4ba6-84cc-af83933e4875
# ╟─cdb488be-2c16-4e30-9ca7-c5f0035f72f4
# ╟─f92daa58-3f98-4b33-94b0-2ad6940e4997
# ╟─96b2a72a-28ea-4c61-8454-e9cc96b07954
# ╟─30a30a99-d6cd-4666-985e-3fadd7154c5a
# ╟─2b75a9ec-9e94-4957-9069-2b308e9fe308
# ╟─90b5d1ae-2c4e-4026-aa6e-fb20582036df
# ╟─4a89f5a9-56b4-45af-9623-16593dadc20c
# ╟─10cc288d-0fbd-4b5d-9023-ac64946e02a1
# ╟─e5623d30-1a09-4798-a2f7-6adf7e4cdb39
# ╟─c68e70d7-d20d-4fa2-8f8a-65ee7027f47b
# ╟─63f3f2a8-dda2-4a47-adfe-662900b2a291
# ╟─31a63eb7-4aac-4246-b243-e9b089252c79
# ╟─7cf64afa-5c18-4844-8de1-6d9c08df32ce
# ╟─b56a4364-57bf-41e5-90bb-2ae93905ac3c
# ╟─45073c38-fd9d-4d3e-bae9-f45de9a18fe7
# ╟─2147676b-0721-4881-90e6-cae828017764
# ╟─183c5ba9-e349-44b7-bb7c-76137aa2718b
# ╟─b7f9e82d-2acf-4ae5-8d2a-d964b6b615f9
# ╟─29c7a707-d177-457b-9876-7fc3b7ea99ef
# ╟─087ed0c5-6911-4029-8250-7ff3116fd123
# ╟─0bd5b05f-a4cd-46ce-8cf1-0109219edb1d
# ╟─0a50d2f8-1515-4a07-b72e-6469d5df6045
# ╟─85824639-7399-40f3-a172-de92ab0043fd
# ╟─2965e339-34b9-4054-980f-2ba91f84a986
# ╟─cf90f9de-e479-4d62-b149-1b2fc1dfc531
# ╟─7e287c1c-035f-49a4-b490-818e655422c7
# ╟─fc3429b3-8770-4fee-8a14-684ec25ad390
# ╟─052b38da-91ba-4e9e-870a-8a28038d2e7a
# ╟─ec28bce0-4d3b-4402-aa6a-bf20205d3ea0
# ╟─6b66ab27-78e5-4fb9-8770-a1be7136cba9
# ╟─065eb446-d121-41f7-a571-52bb90ad139e
# ╟─e9d6a537-b53a-46f3-9288-e17388c98410
# ╟─9f47ffe9-a682-4aa6-bb1c-9e3e57cd8b5d
# ╟─3b83ab8f-0649-49a4-8bf3-055e8c4f5d99
# ╟─3ec3ab5e-3af2-4c1d-972c-07b9c7da3997
# ╟─4278f788-43c5-418a-a945-9a640e50f146
# ╟─eddab0ea-2c24-470c-8583-cd0c1f5c3dd8
# ╟─5e691d06-2906-403f-9a3b-d6312b26af45
# ╟─7eb40aaf-d8c1-42dc-8c15-d54325609684
# ╟─d4588b3f-9c67-40b7-960a-ae1652396a02
# ╟─ad690967-4afb-4fef-b62a-2a57ec7c6c9c
# ╟─01ae8ea1-0d4d-4716-842b-928fb9ad8e8a
# ╟─08d99080-7a46-4a5a-9df2-877f12767bd6
# ╟─b4a7ce77-5e90-4f56-8ffa-caac583eef7b
# ╟─7974f36f-1435-4723-9a92-1ffac8d3bdf6
# ╟─6804e206-efc3-4d8a-a695-312e57795d6c
# ╟─bd41708b-f818-481f-9363-aaa1b6bb9cd1
# ╟─d422b618-10c0-4ce8-86bd-fe0734db8b98
# ╟─8eef20b4-a574-45eb-9d0d-799f2685d42b
# ╟─4b7f0402-7fa2-4753-8e5b-be15ed399668
# ╟─0ed17c6a-f8e5-4c74-b47e-68168ee77fc3
# ╟─7c9c606a-b018-4700-bf80-d1e70da4f0f8
# ╟─18e0f8cb-9a93-4630-b822-36abec311c2e
# ╟─6a4ddc9c-02c0-4722-83f4-0b66ca3e9952
# ╟─c8e95606-2e83-4e74-b5ed-28fe51427e0d
# ╟─23a43a8e-02cc-49b2-96ef-5be79b1a1439
# ╟─3564d6b4-0ea6-45ea-9dfe-7006c2cb7f07
# ╟─43631c73-91f6-41bb-84ca-425c75423a7d
# ╟─a2989783-15df-470e-8093-9652bcb4f046
# ╟─30542234-91ed-4e54-8181-1c40a21b157e
# ╟─0076eb8e-6fca-454a-82ce-7a6ed3ba907b
# ╟─6650b69f-ee23-431a-8608-432850dc8328
# ╟─8abcdb9c-6323-4b2c-b2ec-6db35f6e9aa0
# ╟─48ebc0e7-2f69-4b77-9515-57888c2c653a
# ╟─b28147af-c6b8-4782-8700-ef61d4eb08ad
# ╟─7d462765-f84e-4fd9-85b0-1fe308f6d85f
# ╟─e81a625d-31b3-4ed1-9b8e-3594661413af
# ╟─ac5c13b6-e1c8-4f7d-8531-30711702a61b
# ╟─6e046e3a-cf68-415f-9c6b-baf45b4d3050
# ╟─5a4683bb-ba41-41b3-82a3-31b1d118ee52
# ╟─1ce3b57c-e2f5-4b68-b91d-073a9991b662
# ╟─bd84db51-1ddf-4863-8a58-9cf5dabbeb4f
# ╟─032ba679-8eb5-4341-b00e-2ee46c3b38ed
# ╟─cfa148a3-925c-4b5f-9343-c6760dd0ed0a
# ╟─08e6053f-8055-49c6-8636-50598ad0f652
# ╟─d0ff029c-e6c5-4d63-a219-48f1d0a02e36
# ╟─f12813ed-0579-47e4-a435-a93474391960
# ╟─917a9486-1638-4a78-bcc2-3f634838c3c9
# ╟─f4517aab-b46d-498e-88bb-f0663de68728
# ╟─8c0b1899-c332-4444-b7fe-a822ab7fb34b
# ╟─d518179e-8d39-48a8-86fe-20a58fed5e94
# ╟─b44252dc-6ddc-4869-8454-58bdb6d4b72d
# ╟─d5fc25c1-c91f-4993-aa72-34424f550832
# ╟─e9017c01-f36b-499b-9306-8deab70e7177
# ╟─c76e2821-0229-44b0-9008-e3bcd121e234
# ╟─8803945d-b527-4005-97a1-965885a4036e
# ╟─c2614eba-fafb-44f8-a3d3-3ff38fe60920
# ╟─b13284f8-a5c0-4908-9cae-3ea8dc1f0ba1
# ╟─46244054-fa95-4f93-a30d-77c0821c6958
# ╟─0baa4787-144f-41ef-b5ab-b5c698bf0b87
# ╟─3ffe513b-4480-4d61-9155-b7f2e46174c6
# ╟─cd7c4737-e148-442d-bad5-bbcd214ac317
# ╟─c471b542-e038-48eb-9250-523db7075e87
# ╟─bf153670-1920-4432-a0e2-16fdbaeb0a14
# ╟─c6c887d2-00f8-49ee-b295-1a5783d81642
# ╟─40513dae-61ba-4499-a0eb-f65bf4b33856
# ╟─bde373bb-c241-4d1f-b465-aa1eb1d2dc57
# ╟─dfd03d70-edeb-4652-a120-b801d52ac468
# ╟─072bc880-467f-4203-be68-78866a723aa5
# ╟─387e73ee-74a7-40d0-aceb-0e6f1d1e1e8e
# ╟─4586d453-7a4f-4727-80ea-f867f0c3a227
# ╟─f1e786e7-c9c7-4976-9c02-f171bf09002a
# ╟─3c61fb70-169d-499e-864c-56de5f0a7364
# ╟─6d95c632-422c-4bf8-9f68-6cc94329827f
# ╟─755d72e0-a5be-4f3e-a224-8fcfe2248116
# ╟─c4019743-454c-485e-9c84-8c794f1dad87
# ╟─3a96f527-3e27-49b7-a6c3-c25b71a1538f
