### A Pluto.jl notebook ###
# v0.14.2

using Markdown
using InteractiveUtils

# ╔═╡ 03c30dc8-9e19-11eb-3304-85bc7996c8e6
md"""
# Embedding Julia
"""

# ╔═╡ 03c30e04-9e19-11eb-3981-6342aace8db8
md"""
As we have seen in [Calling C and Fortran Code](@ref), Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).
"""

# ╔═╡ 03c30e22-9e19-11eb-192e-d33fb4130002
md"""
## High-Level Embedding
"""

# ╔═╡ 03c30e40-9e19-11eb-081f-cde967cefba5
md"""
**Note**: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.
"""

# ╔═╡ 03c30e54-9e19-11eb-0c79-673269841143
md"""
We start with a simple C program that initializes Julia and calls some Julia code:
"""

# ╔═╡ 03c31048-9e19-11eb-3c6d-45288bcf433f
#include <julia.h>
JULIA_DEFINE_FAST_TLS() // only define

# ╔═╡ 03c31070-9e19-11eb-28f9-b9ba8c85346a
md"""
In order to build this program you have to put the path to the Julia header into the include path and link against `libjulia`. For instance, when Julia is installed to `$JULIA_DIR`, one can compile the above test program `test.c` with `gcc` using:
"""

# ╔═╡ 03c31188-9e19-11eb-1996-99647750fbd7
gcc -o test

# ╔═╡ 03c311ba-9e19-11eb-1f7a-27e097a5d400
md"""
Alternatively, look at the `embedding.c` program in the Julia source tree in the `test/embedding/` folder. The file `cli/loader_exe.c` program is another simple example of how to set `jl_options` options while linking against `libjulia`.
"""

# ╔═╡ 03c311ce-9e19-11eb-05ee-1ba8d6d5a8e7
md"""
The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling `jl_init`, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use `jl_init_with_image` instead.
"""

# ╔═╡ 03c311e2-9e19-11eb-1ef5-1b8dea1c3a27
md"""
The second statement in the test program evaluates a Julia statement using a call to `jl_eval_string`.
"""

# ╔═╡ 03c311f6-9e19-11eb-094c-a79e6c7aec3e
md"""
Before the program terminates, it is strongly recommended to call `jl_atexit_hook`.  The above example program calls this before returning from `main`.
"""

# ╔═╡ 03c312c6-9e19-11eb-0102-09af328c926f
md"""
!!! note
    Currently, dynamically linking with the `libjulia` shared library requires passing the `RTLD_GLOBAL` option. In Python, this looks like:

    ```
    >>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
    >>> julia.jl_init.argtypes = []
    >>> julia.jl_init()
    250593296
    ```
"""

# ╔═╡ 03c3130e-9e19-11eb-19fe-63afc447ed37
md"""
!!! note
    If the julia program needs to access symbols from the main executable, it may be necessary to add `-Wl,--export-dynamic` linker flag at compile time on Linux in addition to the ones generated by `julia-config.jl` described below. This is not necessary when compiling a shared library.
"""

# ╔═╡ 03c3132a-9e19-11eb-1f7d-6b811adf91bb
md"""
### Using julia-config to automatically determine build parameters
"""

# ╔═╡ 03c3134a-9e19-11eb-14dd-9d0dc2c5ae2c
md"""
The script `julia-config.jl` was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.
"""

# ╔═╡ 03c3137c-9e19-11eb-25ef-b7695d188323
md"""
#### Example
"""

# ╔═╡ 03c31458-9e19-11eb-3cc3-11c7e94a9dff
#include <julia.h>

int main

# ╔═╡ 03c31476-9e19-11eb-3f66-a76742e5a13c
md"""
#### On the command line
"""

# ╔═╡ 03c3148a-9e19-11eb-0c14-457fbae1c8d8
md"""
A simple use of this script is from the command line.  Assuming that `julia-config.jl` is located in `/usr/local/julia/share/julia`, it can be invoked on the command line directly and takes any combination of 3 flags:
"""

# ╔═╡ 03c31504-9e19-11eb-33d7-61b973737c90
/usr

# ╔═╡ 03c31520-9e19-11eb-0db2-072611d56c40
md"""
If the above example source is saved in the file `embed_example.c`, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute `clang` for `gcc`.:
"""

# ╔═╡ 03c3157a-9e19-11eb-0375-c5cc85a40f38
/usr

# ╔═╡ 03c3158e-9e19-11eb-3f18-6528e7614f93
md"""
#### Use in Makefiles
"""

# ╔═╡ 03c315c0-9e19-11eb-2394-bd93d31440d9
md"""
But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the **shell** macro expansions.  Additionally, though many times `julia-config.jl` may be found in the directory `/usr/local`, this is not necessarily the case, but Julia can be used to locate `julia-config.jl` too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:
"""

# ╔═╡ 03c316ec-9e19-11eb-0d4d-4d020e24d3a2
JL_SHARE = $(shell julia

# ╔═╡ 03c3171e-9e19-11eb-27fa-b1005ece05bb
md"""
Now the build command is simply `make`.
"""

# ╔═╡ 03c31730-9e19-11eb-36f6-63463b868d7e
md"""
## High-Level Embedding on Windows with Visual Studio
"""

# ╔═╡ 03c31746-9e19-11eb-033d-87dea99f603f
md"""
If the `JULIA_DIR` environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The `bin` folder under JULIA_DIR should be on the system PATH.
"""

# ╔═╡ 03c3175a-9e19-11eb-09a0-cd914880434b
md"""
We start by opening Visual Studio and creating a new Console Application project. To the 'stdafx.h' header file, add the following lines at the end:
"""

# ╔═╡ 03c317aa-9e19-11eb-068e-8b1f29fbac48
#include <julia.h>

# ╔═╡ 03c317b4-9e19-11eb-334e-6384f862dd90
md"""
Then, replace the main() function in the project with this code:
"""

# ╔═╡ 03c3184a-9e19-11eb-38c3-e96a71e9b322
int main

# ╔═╡ 03c3185e-9e19-11eb-36ab-4d1714a5e18b
md"""
The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.
"""

# ╔═╡ 03c31886-9e19-11eb-17fd-c59bfd57f2f6
md"""
Using the project Properties dialog, go to `C/C++` | `General` and add `$(JULIA_DIR)\include\julia\` to the Additional Include Directories property. Then, go to the `Linker` | `General` section and add `$(JULIA_DIR)\lib` to the Additional Library Directories property. Finally, under `Linker` | `Input`, add `libjulia.dll.a;libopenlibm.dll.a;` to the list of libraries.
"""

# ╔═╡ 03c31898-9e19-11eb-2467-f7ff2ea3b240
md"""
At this point, the project should build and run.
"""

# ╔═╡ 03c318ae-9e19-11eb-16d3-03b25abfa9ee
md"""
## Converting Types
"""

# ╔═╡ 03c318d6-9e19-11eb-2fa0-79b7d9784ff4
md"""
Real applications will not just need to execute expressions, but also return their values to the host program. `jl_eval_string` returns a `jl_value_t*`, which is a pointer to a heap-allocated Julia object. Storing simple data types like [`Float64`](@ref) in this way is called `boxing`, and extracting the stored primitive data is called `unboxing`. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:
"""

# ╔═╡ 03c31b36-9e19-11eb-0413-97eff1ff1015
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

# ╔═╡ 03c31b68-9e19-11eb-3329-9dcc22771ae4
md"""
In order to check whether `ret` is of a specific Julia type, we can use the `jl_isa`, `jl_typeis`, or `jl_is_...` functions. By typing `typeof(sqrt(2.0))` into the Julia shell we can see that the return type is [`Float64`](@ref) (`double` in C). To convert the boxed Julia value into a C double the `jl_unbox_float64` function is used in the above code snippet.
"""

# ╔═╡ 03c31b92-9e19-11eb-2d22-e92b96ff2613
md"""
Corresponding `jl_box_...` functions are used to convert the other way:
"""

# ╔═╡ 03c31d74-9e19-11eb-30f1-8901793cec1e
jl_value_t *a = jl_box_float64(3.0);

# ╔═╡ 03c31d86-9e19-11eb-0cf3-9d97f6c27304
md"""
As we will see next, boxing is required to call Julia functions with specific arguments.
"""

# ╔═╡ 03c31da6-9e19-11eb-1e78-d5a8594b1045
md"""
## Calling Julia Functions
"""

# ╔═╡ 03c31dc2-9e19-11eb-37dd-a35a53b12040
md"""
While `jl_eval_string` allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using `jl_call`:
"""

# ╔═╡ 03c31ff2-9e19-11eb-1cf0-571c6c14c8b1
jl_function_t *func = jl_get_function(jl_base_module, "sqrt");

# ╔═╡ 03c32024-9e19-11eb-37ac-c73374ed6824
md"""
In the first step, a handle to the Julia function `sqrt` is retrieved by calling `jl_get_function`. The first argument passed to `jl_get_function` is a pointer to the `Base` module in which `sqrt` is defined. Then, the double value is boxed using `jl_box_float64`. Finally, in the last step, the function is called using `jl_call1`. `jl_call0`, `jl_call2`, and `jl_call3` functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use `jl_call`:
"""

# ╔═╡ 03c3224a-9e19-11eb-3a6e-1d5910d473fc
jl_value_t *jl_call(jl_function_t *f, jl_value_t *

# ╔═╡ 03c322a4-9e19-11eb-0470-899b5994b124
md"""
Its second argument `args` is an array of `jl_value_t*` arguments and `nargs` is the number of arguments.
"""

# ╔═╡ 03c322c2-9e19-11eb-085f-d144e37dbd59
md"""
## Memory Management
"""

# ╔═╡ 03c322ea-9e19-11eb-10c1-a17509d8d84e
md"""
As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.
"""

# ╔═╡ 03c322fe-9e19-11eb-0c8b-a36673a232e0
md"""
Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.
"""

# ╔═╡ 03c3233a-9e19-11eb-1820-0b6aa24905c6
md"""
The GC can only run when Julia objects are allocated. Calls like `jl_box_float64` perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between `jl_...` calls. But in order to make sure that values can survive `jl_...` calls, we have to tell Julia that we still hold a reference to Julia [root](https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf) values, a process called "GC rooting". Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the `JL_GC_PUSH` macros:
"""

# ╔═╡ 03c3260a-9e19-11eb-1767-0da0657262f4
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

# ╔═╡ 03c32664-9e19-11eb-3b59-03968a829eff
md"""
The `JL_GC_POP` call releases the references established by the previous `JL_GC_PUSH`. Note that `JL_GC_PUSH` stores references on the C stack, so it must be exactly paired with a `JL_GC_POP` before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the `JL_GC_PUSH` was invoked.
"""

# ╔═╡ 03c3268c-9e19-11eb-0ac5-7fa30a065c81
md"""
Several Julia values can be pushed at once using the `JL_GC_PUSH2` , `JL_GC_PUSH3` , `JL_GC_PUSH4` , `JL_GC_PUSH5` , and `JL_GC_PUSH6` macros. To push an array of Julia values one can use the `JL_GC_PUSHARGS` macro, which can be used as follows:
"""

# ╔═╡ 03c3277a-9e19-11eb-0bce-df6c4995cbb3
jl_value_t *

# ╔═╡ 03c327c2-9e19-11eb-33ce-9f5042038d26
md"""
Each scope must have only one call to `JL_GC_PUSH*`. Hence, if all variables cannot be pushed once by a single call to `JL_GC_PUSH*`, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:
"""

# ╔═╡ 03c32a38-9e19-11eb-3f49-816b4813134d
jl_value_t *ret1 = jl_eval_string("sqrt(2.0)");

# ╔═╡ 03c32a56-9e19-11eb-3ca0-71adda8f0fe5
md"""
If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use `JL_GC_PUSH*`. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global `IdDict` that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.
"""

# ╔═╡ 03c32af6-9e19-11eb-29aa-956f7df818bd
// This

# ╔═╡ 03c32b20-9e19-11eb-1a39-f3a0edcde674
md"""
If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a `RefValue{Any}` before it is pushed to `IdDict`. In this approach, the container has to be created or filled in via C code using, for example, the function `jl_new_struct`. If the container is created by `jl_call*`, then you will need to reload the pointer to be used in C code.
"""

# ╔═╡ 03c32b96-9e19-11eb-0129-a3bde2286158
// This

# ╔═╡ 03c32bb2-9e19-11eb-0aca-13dfc9121cf5
md"""
The GC can be allowed to deallocate a variable by removing the reference to it from `refs` using the function `delete!`, provided that no other reference to the variable is kept anywhere:
"""

# ╔═╡ 03c32dc6-9e19-11eb-3910-2f80d648a1cc
jl_function_t* delete = jl_get_function(jl_base_module, "delete!");

# ╔═╡ 03c32df0-9e19-11eb-06ac-db44d02e93d9
md"""
As an alternative for very simple cases, it is possible to just create a global container of type `Vector{Any}` and fetch the elements from that when necessary, or even to create one global variable per pointer using
"""

# ╔═╡ 03c330fa-9e19-11eb-1293-0ba33f26e7ab
jl_set_global(jl_main_module, jl_symbol("var"), var);

# ╔═╡ 03c33118-9e19-11eb-3523-57311ab5425e
md"""
### Updating fields of GC-managed objects
"""

# ╔═╡ 03c33140-9e19-11eb-1cc1-935f12874f38
md"""
The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the `jl_gc_wb` (write barrier) function like so:
"""

# ╔═╡ 03c3330c-9e19-11eb-0b56-b1145f1e03f7
jl_value_t *parent = some_old_value, *child

# ╔═╡ 03c3332c-9e19-11eb-202b-7788a6a1f03d
md"""
It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the `parent` object was just allocated and garbage collection was not run since then. Remember that most `jl_...` functions can sometimes invoke garbage collection.
"""

# ╔═╡ 03c3333e-9e19-11eb-0f35-27483e59ec82
md"""
The write barrier is also necessary for arrays of pointers when updating their data directly. For example:
"""

# ╔═╡ 03c33456-9e19-11eb-2a82-054716d87524
jl_array_t *some_array = ...

# ╔═╡ 03c3346a-9e19-11eb-3bce-67dcee051b94
md"""
### Manipulating the Garbage Collector
"""

# ╔═╡ 03c3347e-9e19-11eb-22f3-b3cacb67e5cd
md"""
There are some functions to control the GC. In normal use cases, these should not be necessary.
"""

# ╔═╡ 03c33640-9e19-11eb-095b-693b07718a4e
md"""
| Function             | Description                                  |
|:-------------------- |:-------------------------------------------- |
| `jl_gc_collect()`    | Force a GC run                               |
| `jl_gc_enable(0)`    | Disable the GC, return previous state as int |
| `jl_gc_enable(1)`    | Enable the GC,  return previous state as int |
| `jl_gc_is_enabled()` | Return current state as int                  |
"""

# ╔═╡ 03c33654-9e19-11eb-26ef-213594916ab9
md"""
## Working with Arrays
"""

# ╔═╡ 03c33668-9e19-11eb-17da-c1ddaa2261a7
md"""
Julia and C can share array data without copying. The next example will show how this works.
"""

# ╔═╡ 03c3367c-9e19-11eb-2ca7-079291c1f831
md"""
Julia arrays are represented in C by the datatype `jl_array_t*`. Basically, `jl_array_t` is a struct that contains:
"""

# ╔═╡ 03c336fe-9e19-11eb-3df0-6d99fedca7db
md"""
  * Information about the datatype
  * A pointer to the data block
  * Information about the sizes of the array
"""

# ╔═╡ 03c33708-9e19-11eb-0864-c7cfb9170168
md"""
To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:
"""

# ╔═╡ 03c338b6-9e19-11eb-2f13-c36114964a41
jl_value_t* array_type = jl_apply_array_type((jl_value_t*)

# ╔═╡ 03c338de-9e19-11eb-1a9b-27c323a5127e
md"""
Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:
"""

# ╔═╡ 03c33a14-9e19-11eb-116e-7777e9f9451e
double *existingArray = (double*)

# ╔═╡ 03c33a34-9e19-11eb-0a99-af793e23342b
md"""
The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call `free` on the data pointer when the array is no longer referenced.
"""

# ╔═╡ 03c33a3c-9e19-11eb-2de3-696bbfbc59bd
md"""
In order to access the data of x, we can use `jl_array_data`:
"""

# ╔═╡ 03c33b90-9e19-11eb-22fc-33d55917bcf9
double *xData = (double*)

# ╔═╡ 03c33b9c-9e19-11eb-237d-71eff59ee6ad
md"""
Now we can fill the array:
"""

# ╔═╡ 03c33c6c-9e19-11eb-0f2e-89556d145eb6
for(size_t i

# ╔═╡ 03c33c80-9e19-11eb-0186-df35432210af
md"""
Now let us call a Julia function that performs an in-place operation on `x`:
"""

# ╔═╡ 03c33e7e-9e19-11eb-2a4d-5515112ca4ff
jl_function_t *func = jl_get_function(jl_base_module, "reverse!");

# ╔═╡ 03c33e92-9e19-11eb-38f7-dfa8d8a14dde
md"""
By printing the array, one can verify that the elements of `x` are now reversed.
"""

# ╔═╡ 03c33ea6-9e19-11eb-3110-ab3d0aa1bc91
md"""
### Accessing Returned Arrays
"""

# ╔═╡ 03c33ecc-9e19-11eb-162e-013182ddf9dc
md"""
If a Julia function returns an array, the return value of `jl_eval_string` and `jl_call` can be cast to a `jl_array_t*`:
"""

# ╔═╡ 03c340a4-9e19-11eb-31f3-8f39dd187db3
jl_function_t *func  = jl_get_function(jl_base_module, "reverse");

# ╔═╡ 03c340c2-9e19-11eb-28a9-271bc3e0a42c
md"""
Now the content of `y` can be accessed as before using `jl_array_data`. As always, be sure to keep a reference to the array while it is in use.
"""

# ╔═╡ 03c340cc-9e19-11eb-109e-79e27d9083bb
md"""
### Multidimensional Arrays
"""

# ╔═╡ 03c340f4-9e19-11eb-3b82-2b1bcb7ee5e2
md"""
Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:
"""

# ╔═╡ 03c3418a-9e19-11eb-38a5-159e4cebd371
// Create

# ╔═╡ 03c341a8-9e19-11eb-3663-fdf35a61471b
md"""
Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling `jl_array_dim`) in order to read as idiomatic C code.
"""

# ╔═╡ 03c341c6-9e19-11eb-15d7-a3358f779bd6
md"""
## Exceptions
"""

# ╔═╡ 03c341ce-9e19-11eb-31d3-c7d25fe1615e
md"""
Julia code can throw exceptions. For example, consider:
"""

# ╔═╡ 03c34324-9e19-11eb-25c6-451285dc3dff
jl_eval_string("this_function_does_not_exist()");

# ╔═╡ 03c34336-9e19-11eb-27bf-b592d71327ea
md"""
This call will appear to do nothing. However, it is possible to check whether an exception was thrown:
"""

# ╔═╡ 03c34630-9e19-11eb-32ce-fd1f59d95459
if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));

# ╔═╡ 03c3464e-9e19-11eb-11f1-3561f81716d4
md"""
If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into `libjulia` with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.
"""

# ╔═╡ 03c34662-9e19-11eb-1f60-e383469ab051
md"""
### Throwing Julia Exceptions
"""

# ╔═╡ 03c3466c-9e19-11eb-2a59-575e1df0b9a1
md"""
When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:
"""

# ╔═╡ 03c34840-9e19-11eb-18ed-f5905579966b
if (!jl_typeis(val, jl_float64_type)) {

# ╔═╡ 03c34856-9e19-11eb-1130-538619b75162
md"""
General exceptions can be raised using the functions:
"""

# ╔═╡ 03c348f6-9e19-11eb-3557-2347060e1b27
void jl_error

# ╔═╡ 03c34932-9e19-11eb-0141-b5467a31d57a
md"""
`jl_error` takes a C string, and `jl_errorf` is called like `printf`:
"""

# ╔═╡ 03c34ab0-9e19-11eb-2792-2f00a59ce8ec
jl_errorf("argument x = %d is too large", x);

# ╔═╡ 03c34ac2-9e19-11eb-3931-d9226ad4d38b
md"""
where in this example `x` is assumed to be an integer.
"""

# ╔═╡ Cell order:
# ╟─03c30dc8-9e19-11eb-3304-85bc7996c8e6
# ╟─03c30e04-9e19-11eb-3981-6342aace8db8
# ╟─03c30e22-9e19-11eb-192e-d33fb4130002
# ╟─03c30e40-9e19-11eb-081f-cde967cefba5
# ╟─03c30e54-9e19-11eb-0c79-673269841143
# ╠═03c31048-9e19-11eb-3c6d-45288bcf433f
# ╟─03c31070-9e19-11eb-28f9-b9ba8c85346a
# ╠═03c31188-9e19-11eb-1996-99647750fbd7
# ╟─03c311ba-9e19-11eb-1f7a-27e097a5d400
# ╟─03c311ce-9e19-11eb-05ee-1ba8d6d5a8e7
# ╟─03c311e2-9e19-11eb-1ef5-1b8dea1c3a27
# ╟─03c311f6-9e19-11eb-094c-a79e6c7aec3e
# ╟─03c312c6-9e19-11eb-0102-09af328c926f
# ╟─03c3130e-9e19-11eb-19fe-63afc447ed37
# ╟─03c3132a-9e19-11eb-1f7d-6b811adf91bb
# ╟─03c3134a-9e19-11eb-14dd-9d0dc2c5ae2c
# ╟─03c3137c-9e19-11eb-25ef-b7695d188323
# ╠═03c31458-9e19-11eb-3cc3-11c7e94a9dff
# ╟─03c31476-9e19-11eb-3f66-a76742e5a13c
# ╟─03c3148a-9e19-11eb-0c14-457fbae1c8d8
# ╠═03c31504-9e19-11eb-33d7-61b973737c90
# ╟─03c31520-9e19-11eb-0db2-072611d56c40
# ╠═03c3157a-9e19-11eb-0375-c5cc85a40f38
# ╟─03c3158e-9e19-11eb-3f18-6528e7614f93
# ╟─03c315c0-9e19-11eb-2394-bd93d31440d9
# ╠═03c316ec-9e19-11eb-0d4d-4d020e24d3a2
# ╟─03c3171e-9e19-11eb-27fa-b1005ece05bb
# ╟─03c31730-9e19-11eb-36f6-63463b868d7e
# ╟─03c31746-9e19-11eb-033d-87dea99f603f
# ╟─03c3175a-9e19-11eb-09a0-cd914880434b
# ╠═03c317aa-9e19-11eb-068e-8b1f29fbac48
# ╟─03c317b4-9e19-11eb-334e-6384f862dd90
# ╠═03c3184a-9e19-11eb-38c3-e96a71e9b322
# ╟─03c3185e-9e19-11eb-36ab-4d1714a5e18b
# ╟─03c31886-9e19-11eb-17fd-c59bfd57f2f6
# ╟─03c31898-9e19-11eb-2467-f7ff2ea3b240
# ╟─03c318ae-9e19-11eb-16d3-03b25abfa9ee
# ╟─03c318d6-9e19-11eb-2fa0-79b7d9784ff4
# ╠═03c31b36-9e19-11eb-0413-97eff1ff1015
# ╟─03c31b68-9e19-11eb-3329-9dcc22771ae4
# ╟─03c31b92-9e19-11eb-2d22-e92b96ff2613
# ╠═03c31d74-9e19-11eb-30f1-8901793cec1e
# ╟─03c31d86-9e19-11eb-0cf3-9d97f6c27304
# ╟─03c31da6-9e19-11eb-1e78-d5a8594b1045
# ╟─03c31dc2-9e19-11eb-37dd-a35a53b12040
# ╠═03c31ff2-9e19-11eb-1cf0-571c6c14c8b1
# ╟─03c32024-9e19-11eb-37ac-c73374ed6824
# ╠═03c3224a-9e19-11eb-3a6e-1d5910d473fc
# ╟─03c322a4-9e19-11eb-0470-899b5994b124
# ╟─03c322c2-9e19-11eb-085f-d144e37dbd59
# ╟─03c322ea-9e19-11eb-10c1-a17509d8d84e
# ╟─03c322fe-9e19-11eb-0c8b-a36673a232e0
# ╟─03c3233a-9e19-11eb-1820-0b6aa24905c6
# ╠═03c3260a-9e19-11eb-1767-0da0657262f4
# ╟─03c32664-9e19-11eb-3b59-03968a829eff
# ╟─03c3268c-9e19-11eb-0ac5-7fa30a065c81
# ╠═03c3277a-9e19-11eb-0bce-df6c4995cbb3
# ╟─03c327c2-9e19-11eb-33ce-9f5042038d26
# ╠═03c32a38-9e19-11eb-3f49-816b4813134d
# ╟─03c32a56-9e19-11eb-3ca0-71adda8f0fe5
# ╠═03c32af6-9e19-11eb-29aa-956f7df818bd
# ╟─03c32b20-9e19-11eb-1a39-f3a0edcde674
# ╠═03c32b96-9e19-11eb-0129-a3bde2286158
# ╟─03c32bb2-9e19-11eb-0aca-13dfc9121cf5
# ╠═03c32dc6-9e19-11eb-3910-2f80d648a1cc
# ╟─03c32df0-9e19-11eb-06ac-db44d02e93d9
# ╠═03c330fa-9e19-11eb-1293-0ba33f26e7ab
# ╟─03c33118-9e19-11eb-3523-57311ab5425e
# ╟─03c33140-9e19-11eb-1cc1-935f12874f38
# ╠═03c3330c-9e19-11eb-0b56-b1145f1e03f7
# ╟─03c3332c-9e19-11eb-202b-7788a6a1f03d
# ╟─03c3333e-9e19-11eb-0f35-27483e59ec82
# ╠═03c33456-9e19-11eb-2a82-054716d87524
# ╟─03c3346a-9e19-11eb-3bce-67dcee051b94
# ╟─03c3347e-9e19-11eb-22f3-b3cacb67e5cd
# ╟─03c33640-9e19-11eb-095b-693b07718a4e
# ╟─03c33654-9e19-11eb-26ef-213594916ab9
# ╟─03c33668-9e19-11eb-17da-c1ddaa2261a7
# ╟─03c3367c-9e19-11eb-2ca7-079291c1f831
# ╟─03c336fe-9e19-11eb-3df0-6d99fedca7db
# ╟─03c33708-9e19-11eb-0864-c7cfb9170168
# ╠═03c338b6-9e19-11eb-2f13-c36114964a41
# ╟─03c338de-9e19-11eb-1a9b-27c323a5127e
# ╠═03c33a14-9e19-11eb-116e-7777e9f9451e
# ╟─03c33a34-9e19-11eb-0a99-af793e23342b
# ╟─03c33a3c-9e19-11eb-2de3-696bbfbc59bd
# ╠═03c33b90-9e19-11eb-22fc-33d55917bcf9
# ╟─03c33b9c-9e19-11eb-237d-71eff59ee6ad
# ╠═03c33c6c-9e19-11eb-0f2e-89556d145eb6
# ╟─03c33c80-9e19-11eb-0186-df35432210af
# ╠═03c33e7e-9e19-11eb-2a4d-5515112ca4ff
# ╟─03c33e92-9e19-11eb-38f7-dfa8d8a14dde
# ╟─03c33ea6-9e19-11eb-3110-ab3d0aa1bc91
# ╟─03c33ecc-9e19-11eb-162e-013182ddf9dc
# ╠═03c340a4-9e19-11eb-31f3-8f39dd187db3
# ╟─03c340c2-9e19-11eb-28a9-271bc3e0a42c
# ╟─03c340cc-9e19-11eb-109e-79e27d9083bb
# ╟─03c340f4-9e19-11eb-3b82-2b1bcb7ee5e2
# ╠═03c3418a-9e19-11eb-38a5-159e4cebd371
# ╟─03c341a8-9e19-11eb-3663-fdf35a61471b
# ╟─03c341c6-9e19-11eb-15d7-a3358f779bd6
# ╟─03c341ce-9e19-11eb-31d3-c7d25fe1615e
# ╠═03c34324-9e19-11eb-25c6-451285dc3dff
# ╟─03c34336-9e19-11eb-27bf-b592d71327ea
# ╠═03c34630-9e19-11eb-32ce-fd1f59d95459
# ╟─03c3464e-9e19-11eb-11f1-3561f81716d4
# ╟─03c34662-9e19-11eb-1f60-e383469ab051
# ╟─03c3466c-9e19-11eb-2a59-575e1df0b9a1
# ╠═03c34840-9e19-11eb-18ed-f5905579966b
# ╟─03c34856-9e19-11eb-1130-538619b75162
# ╠═03c348f6-9e19-11eb-3557-2347060e1b27
# ╟─03c34932-9e19-11eb-0141-b5467a31d57a
# ╠═03c34ab0-9e19-11eb-2792-2f00a59ce8ec
# ╟─03c34ac2-9e19-11eb-3931-d9226ad4d38b
