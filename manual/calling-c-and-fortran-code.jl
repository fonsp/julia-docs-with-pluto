### A Pluto.jl notebook ###
# v0.14.1

using Markdown
using InteractiveUtils

# ╔═╡ 5b999631-7aa6-4775-b64e-296b80359147
md"""
# Calling C and Fortran Code
"""

# ╔═╡ ed2d8fe3-ccd1-4d06-b793-40eb745d9004
md"""
Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy: functions can be called directly from Julia without any \"glue\" code, code generation, or compilation – even from the interactive prompt. This is accomplished just by making an appropriate call with [`ccall`](@ref) syntax, which looks like an ordinary function call.
"""

# ╔═╡ d1e817e4-1a48-4d76-9ddd-8cece7316c78
md"""
The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the `-shared` and `-fPIC` options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. [^1]
"""

# ╔═╡ a7c0c86e-bb26-4680-9311-30b79b15fcaa
md"""
Shared libraries and functions are referenced by a tuple of the form `(:function, \"library\")` or `(\"function\", \"library\")` where `function` is the C-exported function name, and `library` refers to the shared library name.  Shared libraries available in the (platform-specific) load path will be resolved by name.  The full path to the library may also be specified.
"""

# ╔═╡ d0d91499-5da9-451d-922b-5bc9b0f6c0ac
md"""
A function name may be used alone in place of the tuple (just `:function` or `\"function\"`). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.
"""

# ╔═╡ bdf81ef8-54f0-4468-9bd4-112fa9fcf61e
md"""
By default, Fortran compilers [generate mangled names](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via [`ccall`](@ref) you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.
"""

# ╔═╡ 98d92187-52ac-47f9-9fd0-539e6332309d
md"""
Finally, you can use [`ccall`](@ref) to actually generate a call to the library function. The arguments to [`ccall`](@ref) are:
"""

# ╔═╡ 3898c363-eeb5-4a08-a4ed-7b9d6d1d22b6
md"""
1. A `(:function, \"library\")` pair (most common),

    OR

    a `:function` name symbol or `\"function\"` name string (for symbols in the current process or libc),

    OR

    a function pointer (for example, from `dlsym`).
2. The function's return type
3. A tuple of input types, corresponding to the function signature
4. The actual argument values to be passed to the function, if any; each is a separate parameter.
"""

# ╔═╡ 4cf5382f-b2ea-4da0-8230-13eeb6aa71e9
md"""
!!! note
    The `(:function, \"library\")` pair, return type, and input types must be literal constants (i.e., they can't be variables, but see [Non-constant Function Specifications](@ref) below).

    The remaining parameters are evaluated at compile time, when the containing method is defined.
"""

# ╔═╡ 66ffe47f-d09c-40b3-8c4b-cd3286a21216
md"""
!!! note
    See below for how to [map C types to Julia types](@ref mapping-c-types-to-julia).
"""

# ╔═╡ f549e88b-a9d4-48f6-b0d8-7ec7b78be96a
md"""
As a complete but simple example, the following calls the `clock` function from the standard C library on most Unix-derived systems:
"""

# ╔═╡ ebf61fd9-d87a-476a-a35b-c074f89e31e3
t = ccall(:clock, Int32, ())

# ╔═╡ 1950cf7f-48ce-478a-a233-2f45188f0f9b
t

# ╔═╡ 0c90afbf-ecd6-4b3f-b552-0e5b80173470
typeof(t)

# ╔═╡ c4861013-2ef2-4207-bafd-9ce738b8f7ec
md"""
`clock` takes no arguments and returns an [`Int32`](@ref). One common mistake is forgetting that a 1-tuple of argument types must be written with a trailing comma. For example, to call the `getenv` function to get a pointer to the value of an environment variable, one makes a call like this:
"""

# ╔═╡ f2511dd2-25ba-4296-bba9-fec045341280
path = ccall(:getenv, Cstring, (Cstring,), "SHELL")

# ╔═╡ 9aaf5e05-8390-4a15-8d1a-e9eee83d17bd
unsafe_string(path)

# ╔═╡ ccf08a2e-a6b1-45d5-9de8-fdc6ac17735c
md"""
Note that the argument type tuple must be written as `(Cstring,)`, not `(Cstring)`. This is because `(Cstring)` is just the expression `Cstring` surrounded by parentheses, rather than a 1-tuple containing `Cstring`:
"""

# ╔═╡ 82c17ec8-4b42-438c-af09-2a0091f9e183
(Cstring)

# ╔═╡ da260570-1e88-4c7f-b6be-2a57b4d1e778
(Cstring,)

# ╔═╡ c1e6dd29-c6f5-4751-aad7-98f2bf651fbe
md"""
In practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref) uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the `getenv` C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):
"""

# ╔═╡ 6655d522-52a3-45d5-a502-cd3c1b249785
md"""
```julia
function getenv(var::AbstractString)
    val = ccall(:getenv, Cstring, (Cstring,), var)
    if val == C_NULL
        error(\"getenv: undefined variable: \", var)
    end
    return unsafe_string(val)
end
```
"""

# ╔═╡ b3aa6f07-c1f8-46dc-b230-8b2cde306f74
md"""
The C `getenv` function indicates an error by returning `NULL`, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:
"""

# ╔═╡ 45ef0a54-0590-471b-8e32-a61260b98053
getenv("SHELL")

# ╔═╡ 04600626-a81b-49d6-a87a-1d26b6ba63db
getenv("FOOBAR")

# ╔═╡ bf41a573-e5c8-4912-ba66-cc21b13bbe19
md"""
Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named \"libc\". In practice, this function is usually part of the C standard library, and so the \"libc\" portion should be omitted, but we wish to show here the usage of this syntax.
"""

# ╔═╡ 034b7159-5ca7-405c-b191-763a25bc5ffe
md"""
```julia
function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = ccall((:gethostname, \"libc\"), Int32,
                (Ptr{UInt8}, Csize_t),
                hostname, sizeof(hostname))
    Base.systemerror(\"gethostname\", err != 0)
    hostname[end] = 0 # ensure null-termination
    return GC.@preserve hostname unsafe_string(pointer(hostname))
end
```
"""

# ╔═╡ ac18d070-3fd1-4708-a304-0584e53d813a
md"""
This example first allocates an array of bytes. It then calls the C library function `gethostname` to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string.
"""

# ╔═╡ 12d09437-9441-4f86-a1c8-041b5f5350ac
md"""
It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the `Cstring` type here: as the array is uninitialized, it could contain NUL bytes. Converting to a `Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes and could therefore throw a conversion error.
"""

# ╔═╡ adb84d97-468e-48b7-92d5-2a7a7517910a
md"""
Deferencing `pointer(hostname)` with `unsafe_string` is an unsafe operation as it requires access to the memory allocated for `hostname` that may have been in the meanwhile garbage collected. The macro [`GC.@preserve`](@ref) prevents this from happening and therefore accessing an invalid memory location.
"""

# ╔═╡ e8bec8c8-b5fd-44f2-a6ee-fdcb0dd0cb55
md"""
## Creating C-Compatible Julia Function Pointers
"""

# ╔═╡ 97489031-1e22-411c-a5d0-3ff362514800
md"""
It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:
"""

# ╔═╡ af022168-f8ee-47aa-bf2e-9772a05d1e7a
md"""
```c
typedef returntype (*functiontype)(argumenttype, ...)
```
"""

# ╔═╡ db8e200f-ea9c-4153-9a2c-d89b7b2bbc0a
md"""
The macro [`@cfunction`](@ref) generates the C-compatible function pointer for a call to a Julia function. The arguments to [`@cfunction`](@ref) are:
"""

# ╔═╡ c855294b-a026-44a6-b006-8d5988c0b057
md"""
1. A Julia function
2. The function's return type
3. A tuple of input types, corresponding to the function signature
"""

# ╔═╡ 6f0eb8c6-d514-4110-a1cd-eba7ae26269b
md"""
!!! note
    As with `ccall`, the return type and tuple of input types must be literal constants.
"""

# ╔═╡ 510e2c18-6b50-4b98-82ed-f9ed69b09368
md"""
!!! note
    Currently, only the platform-default C calling convention is supported. This means that `@cfunction`-generated pointers cannot be used in calls where WINAPI expects a `stdcall` function on 32-bit Windows, but can be used on WIN64 (where `stdcall` is unified with the C calling convention).
"""

# ╔═╡ af706da5-3d93-493a-abd9-4593f6f19302
md"""
A classic example is the standard C library `qsort` function, declared as:
"""

# ╔═╡ 599094b8-8275-46da-8a7c-6874fefdd268
md"""
```c
void qsort(void *base, size_t nmemb, size_t size,
           int (*compare)(const void*, const void*));
```
"""

# ╔═╡ dce411cc-4d9c-4da0-822e-4aaf5e0b8d98
md"""
The `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes each. `compare` is a callback function which takes pointers to two elements `a` and `b` and returns an integer less/greater than zero if `a` should appear before/after `b` (or zero if any order is permitted).
"""

# ╔═╡ a0cd3131-72aa-4beb-88dd-aa85be2ee4fa
md"""
Now, suppose that we have a 1-d array `A` of values in Julia that we want to sort using the `qsort` function (rather than Julia's built-in `sort` function). Before we consider calling `qsort` and passing arguments, we need to write a comparison function:
"""

# ╔═╡ 03627e0a-d93b-416a-a826-fc272420b3c5
function mycompare(a, b)::Cint
     return (a < b) ? -1 : ((a > b) ? +1 : 0)
 end

# ╔═╡ 37801c25-6c8f-4c74-8698-e7db78a4585a
md"""
`qsort` expects a comparison function that return a C `int`, so we annotate the return type to be `Cint`.
"""

# ╔═╡ a8cc67ea-10bb-4c6f-b162-19c79bc82708
md"""
In order to pass this function to C, we obtain its address using the macro `@cfunction`:
"""

# ╔═╡ c494adef-3c5b-4054-9d3e-5f98331c8d00
mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));

# ╔═╡ 47e77d0c-2b55-472a-85c6-31a25cf8c22c
md"""
[`@cfunction`](@ref) requires three arguments: the Julia function (`mycompare`), the return type (`Cint`), and a literal tuple of the input argument types, in this case to sort an array of `Cdouble` ([`Float64`](@ref)) elements.
"""

# ╔═╡ 1aed865e-9732-47a9-a903-c40988fc0c5c
md"""
The final call to `qsort` looks like this:
"""

# ╔═╡ 79859639-1a5c-487d-a1e9-f4531b64d5fd
A = [1.3, -2.7, 4.4, 3.1]

# ╔═╡ 7bd4d3ba-2318-4450-9829-343ff6e40704
ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),
       A, length(A), sizeof(eltype(A)), mycompare_c)

# ╔═╡ e81d493a-7a4b-4eb1-9909-469ef3c1f332
A

# ╔═╡ 90477928-ec46-4133-af47-5c2d597d0de8
md"""
As the example shows, the original Julia array `A` has now been sorted: `[-2.7, 1.3, 3.1, 4.4]`. Note that Julia [takes care of converting the array to a `Ptr{Cdouble}`](@ref automatic-type-conversion)), computing the size of the element type in bytes, and so on.
"""

# ╔═╡ 05b33f00-3abb-4907-abe9-f506545ed140
md"""
For fun, try inserting a `println(\"mycompare($a, $b)\")` line into `mycompare`, which will allow you to see the comparisons that `qsort` is performing (and to verify that it is really calling the Julia function that you passed to it).
"""

# ╔═╡ c006c81f-fa8f-48aa-a7b2-a8d1e2521bab
md"""
## [Mapping C Types to Julia](@id mapping-c-types-to-julia)
"""

# ╔═╡ 3bf10f8f-8d9e-4012-b8d6-290916e68465
md"""
It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.
"""

# ╔═╡ 9b5e040e-fd7c-4737-9d31-035f339eb319
md"""
Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file.[^2]
"""

# ╔═╡ b069a2a6-2f7a-4323-8cfa-ce6674ca1beb
md"""
### [Automatic Type Conversion](@id automatic-type-conversion)
"""

# ╔═╡ d0ab96bc-baa9-4cdb-b21d-d6e003bc3d75
md"""
Julia automatically inserts calls to the [`Base.cconvert`](@ref) function to convert each argument to the specified type. For example, the following call:
"""

# ╔═╡ f6bd3eba-e7bf-4d1b-a378-237990ad6448
md"""
```julia
ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)
```
"""

# ╔═╡ f00174d7-31d0-41f0-966b-aa80e0a44128
md"""
will behave as if it were written like this:
"""

# ╔═╡ 6373bed7-3cae-4ace-858b-967102d7d0b1
md"""
```julia
ccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
```
"""

# ╔═╡ acc18998-c831-4d18-a205-f1d7e3cc55d2
md"""
[`Base.cconvert`](@ref) normally just calls [`convert`](@ref), but can be defined to return an arbitrary new object more appropriate for passing to C. This should be used to perform all allocations of memory that will be accessed by the C code. For example, this is used to convert an `Array` of objects (e.g. strings) to an array of pointers.
"""

# ╔═╡ 99b727c1-5e75-46ae-ac1a-42ce660bd8d1
md"""
[`Base.unsafe_convert`](@ref) handles conversion to [`Ptr`](@ref) types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.
"""

# ╔═╡ 6dfd6361-ce94-4bdd-9b34-d22f92d2b33c
md"""
### Type Correspondences
"""

# ╔═╡ 6dd10bfd-d8f2-46f6-9a1b-b16fe9071f47
md"""
First, let's review some relevant Julia type terminology:
"""

# ╔═╡ c9780cfa-a4c5-4603-8abf-3f070c5d21dc
md"""
| Syntax / Keyword        | Example                                    | Description                                                                                                                                                                                                                                                       |
|:----------------------- |:------------------------------------------ |:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `mutable struct`        | `BitSet`                                   | \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed. |
| `abstract type`         | `Any`, `AbstractArray{T, N}`, `Complex{T}` | \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.                                                                                                                                         |
| `T{A}`                  | `Vector{Int}`                              | \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).                                                                                                                                                             |
|                         |                                            | \"TypeVar\" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).                                                                                                                                                     |
| `primitive type`        | `Int`, `Float64`                           | \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.                                                                                                                                                                         |
| `struct`                | `Pair{Int, Int}`                           | \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.                                                                                                                                             |
|                         | `ComplexF64` (`isbits`)                    | \"Is-Bits\"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. It is defined by-value, and is stored without a type-tag.                                                                                                        |
| `struct ...; end`       | `nothing`                                  | \"Singleton\" :: a Leaf Type or Struct with no fields.                                                                                                                                                                                                              |
| `(...)` or `tuple(...)` | `(1, 2, 3)`                                | \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.                                                                                                                      |
"""

# ╔═╡ 0b1070c9-f366-4cc6-97af-53e7a733d2d1
md"""
### [Bits Types](@id man-bits-types)
"""

# ╔═╡ e53812c8-0395-408f-83e5-2e5af8b2e66f
md"""
There are several special types to be aware of, as no other type can be defined to behave the same:
"""

# ╔═╡ 9f7caf67-5350-4caa-bb39-90a51c25fb82
md"""
  * `Float32`

    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).
  * `Float64`

    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).
  * `ComplexF32`

    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).
  * `ComplexF64`

    Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).
  * `Signed`

    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran). Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.
"""

# ╔═╡ 6dfec2ea-0c75-45eb-a4db-5979f5ac62c0
md"""
  * `Ref{T}`

    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.
"""

# ╔═╡ 2e9684e6-961f-4831-bdb1-5dea5299e79f
md"""
  * `Array{T,N}`

    When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: Julia requires that the element type of the array matches `T`, and the address of the first element is passed.

    Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted using a call such as `trunc(Int32, a)`.

    To pass an array `A` as a pointer of a different type *without* converting the data beforehand (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you can declare the argument as `Ptr{Cvoid}`.

    If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert`](@ref) will attempt to first make a null-terminated copy of the array with each element replaced by its [`Base.cconvert`](@ref) version. This allows, for example, passing an `argv` pointer array of type `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.
"""

# ╔═╡ 1bfb3b08-a1ff-421c-b3f7-d521d4058e42
md"""
On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when writing portable code (and remembering that an `int` in C is not the same as an `Int` in Julia).
"""

# ╔═╡ 31f3f2d9-531e-4277-9181-76af81be1a43
md"""
**System Independent Types**
"""

# ╔═╡ 78cbe19b-fb88-4c57-ae06-477a90b0b6db
md"""
| C name                                                  | Fortran name             | Standard Julia Alias | Julia Base Type                                                                                             |
|:------------------------------------------------------- |:------------------------ |:-------------------- |:----------------------------------------------------------------------------------------------------------- |
| `unsigned char`                                         | `CHARACTER`              | `Cuchar`             | `UInt8`                                                                                                     |
| `bool` (_Bool in C99+)                                  |                          | `Cuchar`             | `UInt8`                                                                                                     |
| `short`                                                 | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`                                                                                                     |
| `unsigned short`                                        |                          | `Cushort`            | `UInt16`                                                                                                    |
| `int`, `BOOL` (C, typical)                              | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`                                                                                                     |
| `unsigned int`                                          |                          | `Cuint`              | `UInt32`                                                                                                    |
| `long long`                                             | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`                                                                                                     |
| `unsigned long long`                                    |                          | `Culonglong`         | `UInt64`                                                                                                    |
| `intmax_t`                                              |                          | `Cintmax_t`          | `Int64`                                                                                                     |
| `uintmax_t`                                             |                          | `Cuintmax_t`         | `UInt64`                                                                                                    |
| `float`                                                 | `REAL*4i`                | `Cfloat`             | `Float32`                                                                                                   |
| `double`                                                | `REAL*8`                 | `Cdouble`            | `Float64`                                                                                                   |
| `complex float`                                         | `COMPLEX*8`              | `ComplexF32`         | `Complex{Float32}`                                                                                          |
| `complex double`                                        | `COMPLEX*16`             | `ComplexF64`         | `Complex{Float64}`                                                                                          |
| `ptrdiff_t`                                             |                          | `Cptrdiff_t`         | `Int`                                                                                                       |
| `ssize_t`                                               |                          | `Cssize_t`           | `Int`                                                                                                       |
| `size_t`                                                |                          | `Csize_t`            | `UInt`                                                                                                      |
| `void`                                                  |                          |                      | `Cvoid`                                                                                                     |
| `void` and `[[noreturn]]` or `_Noreturn`                |                          |                      | `Union{}`                                                                                                   |
| `void*`                                                 |                          |                      | `Ptr{Cvoid}` (or similarly `Ref{Cvoid}`)                                                                    |
| `T*` (where T represents an appropriately defined type) |                          |                      | `Ref{T}` (T may be safely mutated only if T is an isbits type)                                              |
| `char*` (or `char[]`, e.g. a string)                    | `CHARACTER*N`            |                      | `Cstring` if NUL-terminated, or `Ptr{UInt8}` if not                                                         |
| `char**` (or `*char[]`)                                 |                          |                      | `Ptr{Ptr{UInt8}}`                                                                                           |
| `jl_value_t*` (any Julia Type)                          |                          |                      | `Any`                                                                                                       |
| `jl_value_t* const*` (a reference to a Julia value)     |                          |                      | `Ref{Any}` (const, since mutation would require a write barrier, which is not possible to insert correctly) |
| `va_arg`                                                |                          |                      | Not supported                                                                                               |
| `...` (variadic function specification)                 |                          |                      | `T...` (where `T` is one of the above types, when using the `ccall` function)                               |
| `...` (variadic function specification)                 |                          |                      | `; va_arg1::T, va_arg2::S, etc.` (only supported with `@ccall` macro)                                       |
"""

# ╔═╡ 34d5e9b3-bd63-4c2a-a892-458a2f185273
md"""
The [`Cstring`](@ref) type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring` throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use `Ptr{UInt8}` as the argument type. `Cstring` can also be used as the [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.
"""

# ╔═╡ dec6814f-6cb1-4e49-8ff1-71c2b2ef66c2
md"""
**System Dependent Types**
"""

# ╔═╡ 3e3c15d2-68a9-433a-a1b4-c7c399d7944b
md"""
| C name          | Standard Julia Alias | Julia Base Type                              |
|:--------------- |:-------------------- |:-------------------------------------------- |
| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |
| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |
| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |
| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |
"""

# ╔═╡ 04f5ab1e-ac71-4051-b2f5-04cf0949c3d3
md"""
!!! note
    When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional `Ptr{..}` or `Ref{..}` wrapper around their type specification.
"""

# ╔═╡ f292b81b-6915-44f1-ab2a-cb6099455622
md"""
!!! warning
    For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is expected), or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same effect), as described above, not `String`. Similarly, for array arguments (`T[]` or `T*`), the Julia type should again be `Ptr{T}`, not `Vector{T}`.
"""

# ╔═╡ 957355cf-050e-426d-9316-0369c1b485cc
md"""
!!! warning
    Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or `wint_t`) on all platforms.
"""

# ╔═╡ de36ec28-cfd5-4a3a-b04d-b632683fceb6
md"""
!!! warning
    A return type of `Union{}` means the function will not return, i.e., C++11 `[[noreturn]]` or C11 `_Noreturn` (e.g. `jl_throw` or `longjmp`). Do not use this for functions that return no value (`void`) but do return, use `Cvoid` instead.
"""

# ╔═╡ a4a7b744-9382-4b71-bea6-a44d4f9935e1
md"""
!!! note
    For `wchar_t*` arguments, the Julia type should be [`Cwstring`](@ref) (if the C routine expects a NUL-terminated string), or `Ptr{Cwchar_t}` otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself contains NUL characters).
"""

# ╔═╡ 18c5b3ca-1175-4e29-b920-c9e3d4f84f37
md"""
!!! note
    C functions that take an argument of type `char**` can be called by using a `Ptr{Ptr{UInt8}}` type within Julia. For example, C functions of the form:

    ```c
    int main(int argc, char **argv);
    ```

    can be called via the following Julia code:

    ```julia
    argv = [ \"a.out\", \"arg1\", \"arg2\" ]
    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
    ```
"""

# ╔═╡ ed3cf7cf-cc21-47ff-b795-cfdfa835c200
md"""
!!! note
    For Fortran functions taking variable length strings of type `character(len=*)` the string lengths are provided as *hidden arguments*. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using `Csize_t` as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others *optionally* permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form

    ```fortran
    subroutine test(str1, str2)
    character(len=*) :: str1,str2
    ```

    can be called via the following Julia code, where the lengths are appended

    ```julia
    str1 = \"foo\"
    str2 = \"bar\"
    ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                        str1, str2, sizeof(str1), sizeof(str2))
    ```
"""

# ╔═╡ 3fabe0e4-0eff-4a6d-8cd2-08d9776d1b5a
md"""
!!! warning
    Fortran compilers *may* also add other hidden arguments for pointers, assumed-shape (`:`) and assumed-size (`*`) arrays. Such behaviour can be avoided by using `ISO_C_BINDING` and including `bind(c)` in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only `character(len=1)` will be permitted to pass strings).
"""

# ╔═╡ 6d7dcf31-7125-483b-bafc-9539b230a8e7
md"""
!!! note
    A C function declared to return `Cvoid` will return the value `nothing` in Julia.
"""

# ╔═╡ 6b7dd0bc-dd11-441f-84eb-cdfa87e7db19
md"""
### Struct Type Correspondences
"""

# ╔═╡ d6634609-9059-40cc-9d6b-61f4204d080d
md"""
Composite types such as `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants of F77), can be mirrored in Julia by creating a `struct` definition with the same field layout.
"""

# ╔═╡ e0492629-d53f-4451-a247-f670b159da75
md"""
When used recursively, `isbits` types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an `isbits` struct type and use that instead. Unnamed structs are not possible in the translation to Julia.
"""

# ╔═╡ 18802032-c621-42e2-9baf-a61a713b77ca
md"""
Packed structs and union declarations are not supported by Julia.
"""

# ╔═╡ 4d50c1cc-144f-474c-996f-957a6dd7ea3d
md"""
You can get an approximation of a `union` if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.
"""

# ╔═╡ 56005df8-61ec-4972-83f0-14d3b937d6f1
md"""
Arrays of parameters can be expressed with `NTuple`.  For example, the struct in C notation written as
"""

# ╔═╡ 07a82e24-1f7d-483a-b736-b986defec4e6
md"""
```c
struct B {
    int A[3];
};

b_a_2 = B.A[2];
```
"""

# ╔═╡ fb56d6cc-b688-4d23-86ea-3c7bd2cd14d3
md"""
can be written in Julia as
"""

# ╔═╡ e3ed7d73-1931-4e41-b4af-d95242457957
md"""
```julia
struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)
```
"""

# ╔═╡ 9a3307a2-6ec4-4476-850d-76570fd8a4c2
md"""
Arrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:
"""

# ╔═╡ 8eff7a04-5e4a-4081-9ee9-3d8cb13c2d84
md"""
```c
struct String {
    int strlen;
    char data[];
};
```
"""

# ╔═╡ 158966f1-ad9e-49a5-97cb-75c62468b10f
md"""
In Julia, we can access the parts independently to make a copy of that string:
"""

# ╔═╡ 1f5db1b3-9637-4ae6-983c-0299482ddf67
md"""
```julia
str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
```
"""

# ╔═╡ 7134291b-5446-445c-aa00-f51bb3733f10
md"""
### Type Parameters
"""

# ╔═╡ 51e95413-08f5-4c33-8388-8b1680f56045
md"""
The type arguments to `ccall` and `@cfunction` are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.
"""

# ╔═╡ 3c5b0164-872d-4bd5-8400-7d2294a5f54b
md"""
This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.
"""

# ╔═╡ cf30b875-0d50-4103-91e5-52414cb99776
md"""
However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)` is valid, since `Ptr` is always a word-size primitive type. But, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)` is not valid, since the type layout of `T` is not known statically.
"""

# ╔═╡ 2de42fef-67f6-4e25-8d8a-908772ac7c02
md"""
### SIMD Values
"""

# ╔═╡ 5f829f36-8b2e-4f16-adb9-e43e6889e4eb
md"""
Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.
"""

# ╔═╡ 3234d1e7-86fc-4e7c-b3f1-c8b9df538d9d
md"""
If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of `VecElement` that naturally maps to the SIMD type.  Specifically:
"""

# ╔═╡ addfe930-ec4f-4f3a-82f1-6f4782360abf
md"""
>   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128` on x86 must have a size of 16 bytes.
>   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that is 1, 2, 4 or 8 bytes.
"""

# ╔═╡ 48adff8c-fdf3-4cc7-9065-1be11bd57a58
md"""
For instance, consider this C routine that uses AVX intrinsics:
"""

# ╔═╡ 611dd3e2-8209-425e-8e0c-f3dbb53c4a57
md"""
```c
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
```
"""

# ╔═╡ 5c2cce02-afa2-44c4-a454-c1be819d4800
md"""
The following Julia code calls `dist` using `ccall`:
"""

# ╔═╡ 65282a4f-cbe0-499f-8afd-835222d46963
md"""
```julia
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
```
"""

# ╔═╡ a4da390c-f737-4156-9638-2e903043f4ef
md"""
The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.
"""

# ╔═╡ 0ab12c92-0cf7-4e24-a443-3d5c1eeec178
md"""
### Memory Ownership
"""

# ╔═╡ dbce1d10-5ae5-4ddd-9c0a-a8779ccb50b3
md"""
**malloc/free**
"""

# ╔═╡ ec3401f7-2add-447f-b53f-0a095313955c
md"""
Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with [`Libc.free`](@ref) in Julia, as this may result in the `free` function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.
"""

# ╔═╡ 7561496d-a841-497f-a25d-a1435d2cc23c
md"""
### When to use T, Ptr{T} and Ref{T}
"""

# ╔═╡ 0203ad7f-1042-4597-ae95-9cabaee1ec12
md"""
In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type `T` inside the [`ccall`](@ref), as they are passed by value.  For C code accepting pointers, [`Ref{T}`](@ref) should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert`](@ref). In contrast, pointers returned by the C function called should be declared to be of output type [`Ptr{T}`](@ref), reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type `Ptr{T}` within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.
"""

# ╔═╡ 3dc0374a-62df-4df0-b06f-15e01a91ca13
md"""
In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type `Ref{T}`, as Fortran passes all variables by pointers to memory locations. The return type should either be `Cvoid` for Fortran subroutines, or a `T` for Fortran functions returning the type `T`.
"""

# ╔═╡ 1a956d53-6947-4c16-ae0c-cb6bbe6cf9ff
md"""
## Mapping C Functions to Julia
"""

# ╔═╡ 734e0223-fa76-4f1b-8599-f39105624fa7
md"""
### `ccall` / `@cfunction` argument translation guide
"""

# ╔═╡ e8b249a6-9899-4b0f-81a4-2d24118260ec
md"""
For translating a C argument list to Julia:
"""

# ╔═╡ 5026cfbe-1ee3-42cd-8e77-83a387bc32de
md"""
  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`, `complex`, `enum` or any of their `typedef` equivalents

      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)
      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`
      * argument value will be copied (passed by value)
  * `struct T` (including typedef to a struct)

      * `T`, where `T` is a Julia leaf type
      * argument value will be copied (passed by value)
  * `void*`

      * depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list
      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer
  * `jl_value_t*`

      * `Any`
      * argument value must be a valid Julia object
  * `jl_value_t* const*`

      * `Ref{Any}`
      * argument list must be a valid Julia object (or `C_NULL`)
      * cannot be used for an output parameter, unless the user is able to manage to separate arrange for the object to be GC-preserved
  * `T*`

      * `Ref{T}`, where `T` is the Julia type corresponding to `T`
      * argument value will be copied if it is an `inlinealloc` type (which includes `isbits` otherwise, the value must be a valid Julia object
  * `T (*)(...)` (e.g. a pointer to a function)

      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)
  * `...` (e.g. a vararg)

      * [for `ccall`]: `T...`, where `T` is the single Julia type of all remaining arguments
      * [for `@ccall`]: `; va_arg1::T, va_arg2::S, etc`, where `T` and `S` are the Julia type (i.e. separate the regular arguments from varargs with a `;`)
      * currently unsupported by `@cfunction`
  * `va_arg`

      * not supported by `ccall` or `@cfunction`
"""

# ╔═╡ 2109ae7a-3e8b-43b3-a127-eb8a2392fa47
md"""
### `ccall` / `@cfunction` return type translation guide
"""

# ╔═╡ 2fb57b5f-2960-4145-9a1e-bb13953ce7e8
md"""
For translating a C return type to Julia:
"""

# ╔═╡ 39fc3e9e-39c4-4ae3-8536-1cdde750774b
md"""
  * `void`

      * `Cvoid` (this will return the singleton instance `nothing::Cvoid`)
  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`, `complex`, `enum` or any of their `typedef` equivalents

      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)
      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`
      * argument value will be copied (returned by-value)
  * `struct T` (including typedef to a struct)

      * `T`, where `T` is a Julia Leaf Type
      * argument value will be copied (returned by-value)
  * `void*`

      * depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list
      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer
  * `jl_value_t*`

      * `Any`
      * argument value must be a valid Julia object
  * `jl_value_t**`

      * `Ptr{Any}` (`Ref{Any}` is invalid as a return type)
  * `T*`

      * If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:

          * `Ref{T}`, where `T` is the Julia type corresponding to `T`
          * a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to `jl_value_t*`) or `Ptr{Any}` (corresponding to `jl_value_t**`)
          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type
      * If the memory is owned by C:

          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`
  * `T (*)(...)` (e.g. a pointer to a function)

      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)
"""

# ╔═╡ 4eac7280-ed53-45b4-85b1-b20a3f115ed3
md"""
### Passing Pointers for Modifying Inputs
"""

# ╔═╡ f1323e71-acef-46c6-a253-031f06fdd1fa
md"""
Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a [`ccall`](@ref), you need to first encapsulate the value inside a [`Ref{T}`](@ref) of the appropriate type. When you pass this `Ref` object as an argument, Julia will automatically pass a C pointer to the encapsulated data:
"""

# ╔═╡ c899af9b-eac2-4ea6-9a63-bd0e7187d79f
md"""
```julia
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)
```
"""

# ╔═╡ d8e202a7-1a7c-4e48-8366-97a95cdb85dc
md"""
Upon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`) by `width[]` and `range[]`; that is, they act like zero-dimensional arrays.
"""

# ╔═╡ ac5c6ecc-ae2c-4e77-b757-84a59fdca47b
md"""
## C Wrapper Examples
"""

# ╔═╡ 59971cda-6ad5-4532-b9de-ca2a58e591e9
md"""
Let's start with a simple example of a C wrapper that returns a `Ptr` type:
"""

# ╔═╡ 99125959-d34f-4128-a0ec-c93bbcb77ea7
md"""
```julia
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
```
"""

# ╔═╡ c12e2100-b15a-483a-a5f7-3d57e4722944
md"""
The [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible through `:libgsl`) defines an opaque pointer, `gsl_permutation *`, as the return type of the C function `gsl_permutation_alloc`. As user code never has to look inside the `gsl_permutation` struct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`, that has no internal fields and whose sole purpose is to be placed in the type parameter of a `Ptr` type.  The return type of the [`ccall`](@ref) is declared as `Ptr{gsl_permutation}`, since the memory allocated and pointed to by `output_ptr` is controlled by C.
"""

# ╔═╡ fda8febb-ce71-4f5c-b9b3-7e1ffdeb73ee
md"""
The input `n` is passed by value, and so the function's input signature is simply declared as `(Csize_t,)` without any `Ref` or `Ptr` necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be `(Ref{Csize_t},)`, since Fortran variables are passed by pointers.) Furthermore, `n` can be any type that is convertible to a `Csize_t` integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t, n)`](@ref).
"""

# ╔═╡ 2b984015-715e-466a-9acd-ef3f7ab1470a
md"""
Here is a second example wrapping the corresponding destructor:
"""

# ╔═╡ f46de046-3e54-4284-b097-6f4a3d0a2a76
md"""
```julia
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Cvoid,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
```
"""

# ╔═╡ 24183993-53e4-4e70-95b7-8c87b8a3af48
md"""
Here, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory that `p` points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type `Ptr{gsl_permutation}`, but it is convertible using [`Base.cconvert`](@ref) and therefore
"""

# ╔═╡ b7f16f5f-36a3-4a85-9f4d-b628f55175aa
md"""
Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above of preferred declaration types. Do you see it? The function we are calling is going to free the memory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption). Therefore, it may be preferable to declare the `p` type as `Ptr{gsl_permutation }`, to make it harder for the user to mistakenly pass another sort of object there than one obtained via `gsl_permutation_alloc`.
"""

# ╔═╡ 9e5c6c5f-2c7c-4727-acde-f6aa4d985918
md"""
If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using `p::Ptr{gsl_permutation}` for the method signature of the wrapper and similarly in the [`ccall`](@ref) is also acceptable.
"""

# ╔═╡ 484c6a4b-78d8-438f-8404-8c7b2d894779
md"""
Here is a third example passing Julia arrays:
"""

# ╔═╡ 94dd8e1e-4f34-44c8-a2b7-4b3bdbe83eb1
md"""
```julia
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error(\"GSL error code $errorcode\")
    end
    return result_array
end
```
"""

# ╔═╡ a261d5da-659a-4c5d-a4f4-c6bf5a128ba8
md"""
The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array `result_array`. This variable is declared as a `Ref{Cdouble}`, since its memory is allocated and managed by Julia. The implicit call to [`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks the Julia pointer to a Julia array data structure into a form understandable by C.
"""

# ╔═╡ 3da03834-9593-448d-990f-c2a43b253fda
md"""
## Fortran Wrapper Example
"""

# ╔═╡ dbfb7228-b312-424a-9e89-2f5a9c6406dd
md"""
The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia to Fortran.  On every argument type, we specify `Ref` or `Ptr`. This mangling convention may be specific to your fortran compiler and operating system, and is likely undocumented. However, wrapping each in a `Ref` (or `Ptr`, where equivalent) is a frequent requirement of Fortran compiler implementations:
"""

# ╔═╡ aa7894db-f14d-4d7f-907b-3e4e12c9a6a0
md"""
```julia
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, \"libLAPACK\"),
                    Float64,
                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),
                    n, DX, incx, DY, incy)
    return product
end
```
"""

# ╔═╡ 81cb8b03-eb41-482a-86af-b2099c9ecf70
md"""
## Garbage Collection Safety
"""

# ╔═╡ 879686e6-1d53-4eee-b1c9-327bd391f31c
md"""
When passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer`](@ref) function. Instead define a convert method and pass the variables directly to the [`ccall`](@ref). [`ccall`](@ref) automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref) returns, you must ensure that the object remains visible to the garbage collector. The suggested way to do this is to make a global variable of type `Array{Ref,1}` to hold these values, until the C library notifies you that it is finished with them.
"""

# ╔═╡ 0274264d-415d-4dfe-8c8f-f7ed7d128166
md"""
Whenever you have created a pointer to Julia data, you must ensure the original data exists until you have finished using the pointer. Many methods in Julia such as [`unsafe_load`](@ref) and [`String`](@ref) make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is [`unsafe_wrap`](@ref) which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.
"""

# ╔═╡ 8770fc88-ed31-45ba-ac6d-edc007ee49ce
md"""
The garbage collector does not guarantee any order of finalization. That is, if `a` contained a reference to `b` and both `a` and `b` are due for garbage collection, there is no guarantee that `b` would be finalized after `a`. If proper finalization of `a` depends on `b` being valid, it must be handled in other ways.
"""

# ╔═╡ 598d7ba5-39f0-4d87-88ed-8073e13eca8f
md"""
## Non-constant Function Specifications
"""

# ╔═╡ e18ed446-f598-4808-ade9-1074af50c3c9
md"""
In some cases, the exact name or path of the needed library is not known in advance and must be computed at run time. To handle such cases, the library component of a `(name, library)` specification can be a function call, e.g. `(:dgemm_, find_blas())`. The call expression will be executed when the `ccall` itself is executed. However, it is assumed that the library location does not change once it is determined, so the result of the call can be cached and reused. Therefore, the number of times the expression executes is unspecified, and returning different values for multiple calls results in unspecified behavior.
"""

# ╔═╡ bfb61dd0-bb78-4754-88cc-8a7bf3e86018
md"""
If even more flexibility is needed, it is possible to use computed values as function names by staging through [`eval`](@ref) as follows:
"""

# ╔═╡ b5345acc-92ae-4210-8035-b06855608de5
md"""
```
@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...
```
"""

# ╔═╡ 4ac2b77b-adbd-45c4-b281-330046fd40df
md"""
This expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref) expression, which is then evaluated. Keep in mind that `eval` only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with `$`). For this reason, `eval` is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for [`@cfunction`](@ref).
"""

# ╔═╡ eced45c3-d3e2-4f07-a482-96b181b833fa
md"""
However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.
"""

# ╔═╡ 61db18ae-7dc7-4ab5-91cd-f3c6b35b4bcd
md"""
## Indirect Calls
"""

# ╔═╡ 03d783c5-de20-4012-9831-b7ad056e9d16
md"""
The first argument to [`ccall`](@ref) can also be an expression evaluated at run time. In this case, the expression must evaluate to a `Ptr`, which will be used as the address of the native function to call. This behavior occurs when the first [`ccall`](@ref) argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.
"""

# ╔═╡ a3565ea0-6880-4c77-b559-1267ab115ebb
md"""
For example, you might look up the function via `dlsym`, then cache it in a shared reference for that session. For example:
"""

# ╔═╡ ddc9b3f8-ba7d-4ec3-ba84-d369944bd479
md"""
```julia
macro dlsym(func, lib)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = $zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen(\"mylib\")
ccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())
```
"""

# ╔═╡ 36f2fa92-7418-40df-a069-93e5e300e964
md"""
## Closure cfunctions
"""

# ╔═╡ 3f141ce7-bdac-4dfa-8d7d-623671e16252
md"""
The first argument to [`@cfunction`](@ref) can be marked with a `$`, in which case the return value will instead be a `struct CFunction` which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a [`finalizer`](@ref) when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.
"""

# ╔═╡ 8d960622-5127-4ba5-aada-ee258582c27f
md"""
```julia
function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),
        a, length(a), Base.elsize(a), callback)
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end
```
"""

# ╔═╡ 59f2f9f9-5fa7-4fa6-ad6e-94515d729924
md"""
!!! note
    Closure [`@cfunction`](@ref) rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).
"""

# ╔═╡ c5fc0949-7531-48c8-8c8b-a827f9a16e73
md"""
## Closing a Library
"""

# ╔═╡ 2f63dcdd-88dd-4ded-82be-da7e7b27efa1
md"""
It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the `Libdl` functions to manage the library explicitly, such as:
"""

# ╔═╡ 0e1af819-cc66-4f2a-a5a0-054c8c088bdb
md"""
```julia
lib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
ccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).
Libdl.dlclose(lib) # Close the library explicitly.
```
"""

# ╔═╡ 4aa3fe9b-6ad9-4d7c-a0a4-dafc3fe9767f
md"""
Note that when using `ccall` with the tuple input (e.g., `ccall((:my_fcn, \"./my_lib.so\"), ...)`), the library is opened implicitly and it may not be explicitly closed.
"""

# ╔═╡ 20c76b38-3b67-4474-9530-327cc833b93f
md"""
## Calling Convention
"""

# ╔═╡ 783f0b90-2a3a-4193-980d-81636a63aee9
md"""
The second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: `stdcall`, `cdecl`, `fastcall`, and `thiscall` (no-op on 64-bit Windows). For example (from `base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the correct signature for Windows:
"""

# ╔═╡ a510ebef-e8c3-45ed-83c0-190f5594608c
md"""
```julia
hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
```
"""

# ╔═╡ 881a22d5-bb49-4f4f-a29b-bfd80278f373
md"""
For more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions).
"""

# ╔═╡ b83da0b2-753f-4db6-99c9-6aa52fd4284f
md"""
There is one additional special calling convention [`llvmcall`](@ref Base.llvmcall), which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for [CUDA](http://llvm.org/docs/NVPTXUsage.html), we need to be able to read the thread index:
"""

# ╔═╡ 16746faf-645f-4ed6-9fc0-b3b58760449c
md"""
```julia
ccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())
```
"""

# ╔═╡ 16f40708-c14c-4675-879e-db5178309fb4
md"""
As with any `ccall`, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by `Core.Intrinsics`.
"""

# ╔═╡ 15307d30-78b0-4b2d-9713-ce2e9ffed1df
md"""
## Accessing Global Variables
"""

# ╔═╡ 43099ea1-ccf2-4eb0-8227-22c0d51c8b33
md"""
Global variables exported by native libraries can be accessed by name using the [`cglobal`](@ref) function. The arguments to [`cglobal`](@ref) are a symbol specification identical to that used by [`ccall`](@ref), and a type describing the value stored in the variable:
"""

# ╔═╡ 15a9a642-48f3-4666-8ae1-498a2e197da7
cglobal((:errno, :libc), Int32)

# ╔═╡ 332a5e40-53f8-43f3-abc7-73980e058cb9
md"""
The result is a pointer giving the address of the value. The value can be manipulated through this pointer using [`unsafe_load`](@ref) and [`unsafe_store!`](@ref).
"""

# ╔═╡ 2b89649c-45fb-4395-988c-08eca997b735
md"""
!!! note
    This `errno` symbol may not be found in a library named \"libc\", as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the `errno` symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.
"""

# ╔═╡ c4ac174d-8e16-4f98-836b-af74c792c3fa
md"""
## Accessing Data through a Pointer
"""

# ╔═╡ 6b15b06f-d795-4e7f-ac66-cc425c7de29b
md"""
The following methods are described as \"unsafe\" because a bad pointer or type declaration can cause Julia to terminate abruptly.
"""

# ╔═╡ 99dcf169-bfd5-45b8-b485-ad9802742c37
md"""
Given a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory into a Julia object using `unsafe_load(ptr, [index])`. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of [`getindex`](@ref) and [`setindex!`](@ref) (e.g. `[]` access syntax).
"""

# ╔═╡ d7c89628-47c6-4145-96f4-d4a230963b44
md"""
The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.
"""

# ╔═╡ 7edcee03-87e5-4788-abcb-2d60d48662f1
md"""
If `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector.  If the `Ptr` itself is actually a `jl_value_t*`, it can be converted back to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref). (Julia values `v` can be converted to `jl_value_t*` pointers, as `Ptr{Cvoid}`, by calling [`pointer_from_objref(v)`](@ref).)
"""

# ╔═╡ 1c35f0ce-1863-42c7-9ef1-facec6497478
md"""
The reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref). Currently, this is only supported for primitive types or other pointer-free (`isbits`) immutable struct types.
"""

# ╔═╡ 580f80d0-3086-4f26-837e-6da9f7b8edca
md"""
Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.
"""

# ╔═╡ 617d0ea7-d2a4-4e6a-a890-5796a261298d
md"""
If the pointer of interest is a plain-data array (primitive type or immutable struct), the function [`unsafe_wrap(Array, ptr,dims, own = false)`](@ref) may be more useful. The final parameter should be true if Julia should \"take ownership\" of the underlying buffer and call `free(ptr)` when the returned `Array` object is finalized.  If the `own` parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.
"""

# ╔═╡ 6884e787-8aad-442e-94e1-cfb479a25b28
md"""
Arithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer arithmetic. Adding an integer to a `Ptr` in Julia always moves the pointer by some number of *bytes*, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.
"""

# ╔═╡ 82aef2de-ea05-4cbb-bbce-120854e9f291
md"""
## Thread-safety
"""

# ╔═╡ 9d4ada82-9516-41a7-8797-bb16cf4b2663
md"""
Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra precautions. In particular, you'll need to set up a two-layered system: the C callback should only *schedule* (via Julia's event loop) the execution of your \"real\" callback. To do this, create an [`AsyncCondition`](@ref Base.AsyncCondition) object and [`wait`](@ref) on it:
"""

# ╔═╡ 87036c76-cba6-4d17-af73-74e18dce7114
md"""
```julia
cond = Base.AsyncCondition()
wait(cond)
```
"""

# ╔═╡ d8678493-128f-487e-a17f-d7e8a80cfd3c
md"""
The callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing `cond.handle` as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.
"""

# ╔═╡ 5954172d-a4f3-4c76-add0-f1105d330ebc
md"""
Note that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup notification to the condition.
"""

# ╔═╡ 179b5805-afcd-48d2-8427-18349f802e1b
md"""
## More About Callbacks
"""

# ╔═╡ d21770d4-bd4e-43b2-b06a-e8831b420dc0
md"""
For more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback).
"""

# ╔═╡ 46713603-216e-4fdc-8a83-25e965ac7496
md"""
## C++
"""

# ╔═╡ 4d358ff6-5e84-4a0e-a78e-8a3409fa460e
md"""
For direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. For tools to create C++ bindings, see the [CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) package.
"""

# ╔═╡ 769cb8e1-a873-488c-b03f-250f46ee1605
md"""
[^1]: Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.
"""

# ╔═╡ 6cf2367f-3e01-4074-b74e-889e9f750b1e
md"""
[^2]: The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate Julia code from a C header file.
"""

# ╔═╡ Cell order:
# ╟─5b999631-7aa6-4775-b64e-296b80359147
# ╟─ed2d8fe3-ccd1-4d06-b793-40eb745d9004
# ╟─d1e817e4-1a48-4d76-9ddd-8cece7316c78
# ╟─a7c0c86e-bb26-4680-9311-30b79b15fcaa
# ╟─d0d91499-5da9-451d-922b-5bc9b0f6c0ac
# ╟─bdf81ef8-54f0-4468-9bd4-112fa9fcf61e
# ╟─98d92187-52ac-47f9-9fd0-539e6332309d
# ╟─3898c363-eeb5-4a08-a4ed-7b9d6d1d22b6
# ╟─4cf5382f-b2ea-4da0-8230-13eeb6aa71e9
# ╟─66ffe47f-d09c-40b3-8c4b-cd3286a21216
# ╟─f549e88b-a9d4-48f6-b0d8-7ec7b78be96a
# ╠═ebf61fd9-d87a-476a-a35b-c074f89e31e3
# ╠═1950cf7f-48ce-478a-a233-2f45188f0f9b
# ╠═0c90afbf-ecd6-4b3f-b552-0e5b80173470
# ╟─c4861013-2ef2-4207-bafd-9ce738b8f7ec
# ╠═f2511dd2-25ba-4296-bba9-fec045341280
# ╠═9aaf5e05-8390-4a15-8d1a-e9eee83d17bd
# ╟─ccf08a2e-a6b1-45d5-9de8-fdc6ac17735c
# ╠═82c17ec8-4b42-438c-af09-2a0091f9e183
# ╠═da260570-1e88-4c7f-b6be-2a57b4d1e778
# ╟─c1e6dd29-c6f5-4751-aad7-98f2bf651fbe
# ╟─6655d522-52a3-45d5-a502-cd3c1b249785
# ╟─b3aa6f07-c1f8-46dc-b230-8b2cde306f74
# ╠═45ef0a54-0590-471b-8e32-a61260b98053
# ╠═04600626-a81b-49d6-a87a-1d26b6ba63db
# ╟─bf41a573-e5c8-4912-ba66-cc21b13bbe19
# ╟─034b7159-5ca7-405c-b191-763a25bc5ffe
# ╟─ac18d070-3fd1-4708-a304-0584e53d813a
# ╟─12d09437-9441-4f86-a1c8-041b5f5350ac
# ╟─adb84d97-468e-48b7-92d5-2a7a7517910a
# ╟─e8bec8c8-b5fd-44f2-a6ee-fdcb0dd0cb55
# ╟─97489031-1e22-411c-a5d0-3ff362514800
# ╟─af022168-f8ee-47aa-bf2e-9772a05d1e7a
# ╟─db8e200f-ea9c-4153-9a2c-d89b7b2bbc0a
# ╟─c855294b-a026-44a6-b006-8d5988c0b057
# ╟─6f0eb8c6-d514-4110-a1cd-eba7ae26269b
# ╟─510e2c18-6b50-4b98-82ed-f9ed69b09368
# ╟─af706da5-3d93-493a-abd9-4593f6f19302
# ╟─599094b8-8275-46da-8a7c-6874fefdd268
# ╟─dce411cc-4d9c-4da0-822e-4aaf5e0b8d98
# ╟─a0cd3131-72aa-4beb-88dd-aa85be2ee4fa
# ╠═03627e0a-d93b-416a-a826-fc272420b3c5
# ╟─37801c25-6c8f-4c74-8698-e7db78a4585a
# ╟─a8cc67ea-10bb-4c6f-b162-19c79bc82708
# ╠═c494adef-3c5b-4054-9d3e-5f98331c8d00
# ╟─47e77d0c-2b55-472a-85c6-31a25cf8c22c
# ╟─1aed865e-9732-47a9-a903-c40988fc0c5c
# ╠═79859639-1a5c-487d-a1e9-f4531b64d5fd
# ╠═7bd4d3ba-2318-4450-9829-343ff6e40704
# ╠═e81d493a-7a4b-4eb1-9909-469ef3c1f332
# ╟─90477928-ec46-4133-af47-5c2d597d0de8
# ╟─05b33f00-3abb-4907-abe9-f506545ed140
# ╟─c006c81f-fa8f-48aa-a7b2-a8d1e2521bab
# ╟─3bf10f8f-8d9e-4012-b8d6-290916e68465
# ╟─9b5e040e-fd7c-4737-9d31-035f339eb319
# ╟─b069a2a6-2f7a-4323-8cfa-ce6674ca1beb
# ╟─d0ab96bc-baa9-4cdb-b21d-d6e003bc3d75
# ╟─f6bd3eba-e7bf-4d1b-a378-237990ad6448
# ╟─f00174d7-31d0-41f0-966b-aa80e0a44128
# ╟─6373bed7-3cae-4ace-858b-967102d7d0b1
# ╟─acc18998-c831-4d18-a205-f1d7e3cc55d2
# ╟─99b727c1-5e75-46ae-ac1a-42ce660bd8d1
# ╟─6dfd6361-ce94-4bdd-9b34-d22f92d2b33c
# ╟─6dd10bfd-d8f2-46f6-9a1b-b16fe9071f47
# ╟─c9780cfa-a4c5-4603-8abf-3f070c5d21dc
# ╟─0b1070c9-f366-4cc6-97af-53e7a733d2d1
# ╟─e53812c8-0395-408f-83e5-2e5af8b2e66f
# ╟─9f7caf67-5350-4caa-bb39-90a51c25fb82
# ╟─6dfec2ea-0c75-45eb-a4db-5979f5ac62c0
# ╟─2e9684e6-961f-4831-bdb1-5dea5299e79f
# ╟─1bfb3b08-a1ff-421c-b3f7-d521d4058e42
# ╟─31f3f2d9-531e-4277-9181-76af81be1a43
# ╟─78cbe19b-fb88-4c57-ae06-477a90b0b6db
# ╟─34d5e9b3-bd63-4c2a-a892-458a2f185273
# ╟─dec6814f-6cb1-4e49-8ff1-71c2b2ef66c2
# ╟─3e3c15d2-68a9-433a-a1b4-c7c399d7944b
# ╟─04f5ab1e-ac71-4051-b2f5-04cf0949c3d3
# ╟─f292b81b-6915-44f1-ab2a-cb6099455622
# ╟─957355cf-050e-426d-9316-0369c1b485cc
# ╟─de36ec28-cfd5-4a3a-b04d-b632683fceb6
# ╟─a4a7b744-9382-4b71-bea6-a44d4f9935e1
# ╟─18c5b3ca-1175-4e29-b920-c9e3d4f84f37
# ╟─ed3cf7cf-cc21-47ff-b795-cfdfa835c200
# ╟─3fabe0e4-0eff-4a6d-8cd2-08d9776d1b5a
# ╟─6d7dcf31-7125-483b-bafc-9539b230a8e7
# ╟─6b7dd0bc-dd11-441f-84eb-cdfa87e7db19
# ╟─d6634609-9059-40cc-9d6b-61f4204d080d
# ╟─e0492629-d53f-4451-a247-f670b159da75
# ╟─18802032-c621-42e2-9baf-a61a713b77ca
# ╟─4d50c1cc-144f-474c-996f-957a6dd7ea3d
# ╟─56005df8-61ec-4972-83f0-14d3b937d6f1
# ╟─07a82e24-1f7d-483a-b736-b986defec4e6
# ╟─fb56d6cc-b688-4d23-86ea-3c7bd2cd14d3
# ╟─e3ed7d73-1931-4e41-b4af-d95242457957
# ╟─9a3307a2-6ec4-4476-850d-76570fd8a4c2
# ╟─8eff7a04-5e4a-4081-9ee9-3d8cb13c2d84
# ╟─158966f1-ad9e-49a5-97cb-75c62468b10f
# ╟─1f5db1b3-9637-4ae6-983c-0299482ddf67
# ╟─7134291b-5446-445c-aa00-f51bb3733f10
# ╟─51e95413-08f5-4c33-8388-8b1680f56045
# ╟─3c5b0164-872d-4bd5-8400-7d2294a5f54b
# ╟─cf30b875-0d50-4103-91e5-52414cb99776
# ╟─2de42fef-67f6-4e25-8d8a-908772ac7c02
# ╟─5f829f36-8b2e-4f16-adb9-e43e6889e4eb
# ╟─3234d1e7-86fc-4e7c-b3f1-c8b9df538d9d
# ╟─addfe930-ec4f-4f3a-82f1-6f4782360abf
# ╟─48adff8c-fdf3-4cc7-9065-1be11bd57a58
# ╟─611dd3e2-8209-425e-8e0c-f3dbb53c4a57
# ╟─5c2cce02-afa2-44c4-a454-c1be819d4800
# ╟─65282a4f-cbe0-499f-8afd-835222d46963
# ╟─a4da390c-f737-4156-9638-2e903043f4ef
# ╟─0ab12c92-0cf7-4e24-a443-3d5c1eeec178
# ╟─dbce1d10-5ae5-4ddd-9c0a-a8779ccb50b3
# ╟─ec3401f7-2add-447f-b53f-0a095313955c
# ╟─7561496d-a841-497f-a25d-a1435d2cc23c
# ╟─0203ad7f-1042-4597-ae95-9cabaee1ec12
# ╟─3dc0374a-62df-4df0-b06f-15e01a91ca13
# ╟─1a956d53-6947-4c16-ae0c-cb6bbe6cf9ff
# ╟─734e0223-fa76-4f1b-8599-f39105624fa7
# ╟─e8b249a6-9899-4b0f-81a4-2d24118260ec
# ╟─5026cfbe-1ee3-42cd-8e77-83a387bc32de
# ╟─2109ae7a-3e8b-43b3-a127-eb8a2392fa47
# ╟─2fb57b5f-2960-4145-9a1e-bb13953ce7e8
# ╟─39fc3e9e-39c4-4ae3-8536-1cdde750774b
# ╟─4eac7280-ed53-45b4-85b1-b20a3f115ed3
# ╟─f1323e71-acef-46c6-a253-031f06fdd1fa
# ╟─c899af9b-eac2-4ea6-9a63-bd0e7187d79f
# ╟─d8e202a7-1a7c-4e48-8366-97a95cdb85dc
# ╟─ac5c6ecc-ae2c-4e77-b757-84a59fdca47b
# ╟─59971cda-6ad5-4532-b9de-ca2a58e591e9
# ╟─99125959-d34f-4128-a0ec-c93bbcb77ea7
# ╟─c12e2100-b15a-483a-a5f7-3d57e4722944
# ╟─fda8febb-ce71-4f5c-b9b3-7e1ffdeb73ee
# ╟─2b984015-715e-466a-9acd-ef3f7ab1470a
# ╟─f46de046-3e54-4284-b097-6f4a3d0a2a76
# ╟─24183993-53e4-4e70-95b7-8c87b8a3af48
# ╟─b7f16f5f-36a3-4a85-9f4d-b628f55175aa
# ╟─9e5c6c5f-2c7c-4727-acde-f6aa4d985918
# ╟─484c6a4b-78d8-438f-8404-8c7b2d894779
# ╟─94dd8e1e-4f34-44c8-a2b7-4b3bdbe83eb1
# ╟─a261d5da-659a-4c5d-a4f4-c6bf5a128ba8
# ╟─3da03834-9593-448d-990f-c2a43b253fda
# ╟─dbfb7228-b312-424a-9e89-2f5a9c6406dd
# ╟─aa7894db-f14d-4d7f-907b-3e4e12c9a6a0
# ╟─81cb8b03-eb41-482a-86af-b2099c9ecf70
# ╟─879686e6-1d53-4eee-b1c9-327bd391f31c
# ╟─0274264d-415d-4dfe-8c8f-f7ed7d128166
# ╟─8770fc88-ed31-45ba-ac6d-edc007ee49ce
# ╟─598d7ba5-39f0-4d87-88ed-8073e13eca8f
# ╟─e18ed446-f598-4808-ade9-1074af50c3c9
# ╟─bfb61dd0-bb78-4754-88cc-8a7bf3e86018
# ╟─b5345acc-92ae-4210-8035-b06855608de5
# ╟─4ac2b77b-adbd-45c4-b281-330046fd40df
# ╟─eced45c3-d3e2-4f07-a482-96b181b833fa
# ╟─61db18ae-7dc7-4ab5-91cd-f3c6b35b4bcd
# ╟─03d783c5-de20-4012-9831-b7ad056e9d16
# ╟─a3565ea0-6880-4c77-b559-1267ab115ebb
# ╟─ddc9b3f8-ba7d-4ec3-ba84-d369944bd479
# ╟─36f2fa92-7418-40df-a069-93e5e300e964
# ╟─3f141ce7-bdac-4dfa-8d7d-623671e16252
# ╟─8d960622-5127-4ba5-aada-ee258582c27f
# ╟─59f2f9f9-5fa7-4fa6-ad6e-94515d729924
# ╟─c5fc0949-7531-48c8-8c8b-a827f9a16e73
# ╟─2f63dcdd-88dd-4ded-82be-da7e7b27efa1
# ╟─0e1af819-cc66-4f2a-a5a0-054c8c088bdb
# ╟─4aa3fe9b-6ad9-4d7c-a0a4-dafc3fe9767f
# ╟─20c76b38-3b67-4474-9530-327cc833b93f
# ╟─783f0b90-2a3a-4193-980d-81636a63aee9
# ╟─a510ebef-e8c3-45ed-83c0-190f5594608c
# ╟─881a22d5-bb49-4f4f-a29b-bfd80278f373
# ╟─b83da0b2-753f-4db6-99c9-6aa52fd4284f
# ╟─16746faf-645f-4ed6-9fc0-b3b58760449c
# ╟─16f40708-c14c-4675-879e-db5178309fb4
# ╟─15307d30-78b0-4b2d-9713-ce2e9ffed1df
# ╟─43099ea1-ccf2-4eb0-8227-22c0d51c8b33
# ╠═15a9a642-48f3-4666-8ae1-498a2e197da7
# ╟─332a5e40-53f8-43f3-abc7-73980e058cb9
# ╟─2b89649c-45fb-4395-988c-08eca997b735
# ╟─c4ac174d-8e16-4f98-836b-af74c792c3fa
# ╟─6b15b06f-d795-4e7f-ac66-cc425c7de29b
# ╟─99dcf169-bfd5-45b8-b485-ad9802742c37
# ╟─d7c89628-47c6-4145-96f4-d4a230963b44
# ╟─7edcee03-87e5-4788-abcb-2d60d48662f1
# ╟─1c35f0ce-1863-42c7-9ef1-facec6497478
# ╟─580f80d0-3086-4f26-837e-6da9f7b8edca
# ╟─617d0ea7-d2a4-4e6a-a890-5796a261298d
# ╟─6884e787-8aad-442e-94e1-cfb479a25b28
# ╟─82aef2de-ea05-4cbb-bbce-120854e9f291
# ╟─9d4ada82-9516-41a7-8797-bb16cf4b2663
# ╟─87036c76-cba6-4d17-af73-74e18dce7114
# ╟─d8678493-128f-487e-a17f-d7e8a80cfd3c
# ╟─5954172d-a4f3-4c76-add0-f1105d330ebc
# ╟─179b5805-afcd-48d2-8427-18349f802e1b
# ╟─d21770d4-bd4e-43b2-b06a-e8831b420dc0
# ╟─46713603-216e-4fdc-8a83-25e965ac7496
# ╟─4d358ff6-5e84-4a0e-a78e-8a3409fa460e
# ╟─769cb8e1-a873-488c-b03f-250f46ee1605
# ╟─6cf2367f-3e01-4074-b74e-889e9f750b1e
